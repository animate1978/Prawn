<?xml-stylesheet type="text/xsl" href="block.xsl"?>
<!-- Copyright 2009, Romain Behar <romainbehar@users.sourceforge.net>; 
This file is part of Shrimp 2.
Shrimp 2 is free software: you can redistribute it and/or modify 
it under the terms of the GNU General Public License as published by 
the Free Software Foundation, either version 3 of the License, or 
(at your option) any later version. 
Shrimp 2 is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of 
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
GNU General Public License for more details. 
You should have received a copy of the GNU General Public License 
along with Shrimp 2.  If not, see <http://www.gnu.org/licenses/>.-->
<block>
<shrimp type="function" name="AOV_Ambient" description="Ambient AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_ambient += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the ambient AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Caustics" description="Caustics AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_caustics += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the caustics AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Diffuse" description="Diffuse AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_diffuse += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the diffuse AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_IndDiffuse" description="Indirect Diffuse AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_indirectdiffuse += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the indirect diffuse AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Occlusion" description="Occlusion AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="float" multi="+" default="0"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="float"/>
	<rsl_code>
		aov_occlusion += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the occlusion AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Reflection" description="Reflection AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_reflection += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the reflection AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Refraction" description="Refraction AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_refraction += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the refraction AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_RimLight" description="Rim Lighting AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_rimlighting += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the rim lighting AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Scatter" description="Scattering AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_scattering += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the scattering AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Shadows" description="Shadows AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_shadows += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the shadows AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Specular" description="Specular AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_specular += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the specular AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_SpecColor" description="Specular Color AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_specularcolor += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the specular color AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_SurfColor" description="Surface Color AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_surfacecolor += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the surface color AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="AOV_Translucence" description="Translucence AOV" author="rconstruct">
	<input name="in" description="Value for AOV" storage="varying" type="color" multi="+" default="color(0)"/>
	<output name="val" description="Value passed for AOV" storage="varying" type="color"/>
	<rsl_code>
		aov_translucence += $(in);
		$(val) = $(in);
	</rsl_code>
	<usage>Passes the values connected to the input, to the translucence AOV. The preset AOVs are aov_surfacecolor, aov_ambient, aov_diffuse, aov_indirectdiffuse, aov_specular, aov_specularcolor, aov_reflection, aov_refraction, aov_rimlighting, aov_scattering, aov_translucence, aov_shadows, aov_occlusion, aov_caustics. Note that all shading models blocks already have assigned AOVs to their respective components, as well as some other blocks, see the blocks information for details.</usage>
</shrimp>

<shrimp type="function" name="Bias" description="Adjust bias." author="rconstruct">
	<input name="input" description="Input to be adjusted" type_parent="value" type="float color" default="color(1)"/>
	<input name="bias" description="Bias value" type="float" default="0.5"/>
	<output name="value" description="Adjusted value." type="float color"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	$(value) = $(value:type) bias( $(input), $(bias) );
	</rsl_code>
	<usage>Bias function, operates on float or color types, it&apos;s similar to a brighness adjustement.</usage>
</shrimp>

<shrimp type="function" name="Ctransform" description="Transform to a different color space" author="rconstruct">
	<input name="Cin" description="color to transform" type="color" type_parent="value" default="color(0)"/>
	<input name="from_space" description="The color space to transform from" storage="uniform" type="string" default="&quot;rgb&quot;"/>
	<input name="to_space" description="The color space to transform to" storage="uniform" type="string" default="&quot;hsv&quot;"/>
	<output name="Cout" description="The transformed color" type="color"/>
	<rsl_code>
		$(Cout) = ctransform( $(from_space), $(to_space), $(Cin) );
	</rsl_code>
<usage>Transforms the color &quot;Cin&quot; from &quot;fromspace&quot; to &quot;tospace&quot;. If fromspace isn&apos;t passed, it&apos;s assumed to be RGB. Color spaces are &quot;rgb&quot; (red, green, and blue), &quot;hsv&quot; (hue, saturation, value), &quot;hsl&quot; (hue, saturation, lightness), &quot;xyz&quot; or &quot;XYZ&quot; (CIE XYZ coordinates), &quot;xyY&quot; or &quot;xyy&quot; (CIE xy and Y), and &quot;YIQ&quot; or &quot;yiq&quot; (NTSC coordinates).</usage>
</shrimp>

<shrimp type="function" name="Gain" description="Adjust gain." author="rconstruct">
	<input name="input" description="Input to be adjusted" type_parent="value" type="float color" default="color(1)"/>
	<input name="gain" description="Gain value" type="float" default="0.5"/>
	<output name="value" description="Adjusted value." type="float color"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	$(value) = $(value:type) gain( $(input), $(gain) );
	</rsl_code>
	<usage>The gain function operates on both float and color types, and it&apos;s similar to a contrast adjustment.</usage>
</shrimp>

<shrimp type="function" name="Gamma" description="Gamma adjustement function" author="rconstruct">
	<input name="input" description="Input to be adjusted" type_parent="value" type="float color" default="color(1)"/>
	<input name="gamma" description="Range lower point" type="float" default="1"/>
	<output name="value" description="Remapped value." type="float color"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	$(value) = $(value:type) gamma( $(input), $(gamma) );
	</rsl_code>
	<usage>A gamma adjustment function, that operates on float and color types.</usage>
</shrimp>

<shrimp type="function" name="GetCol" description="Get the components of a color" author="rconstruct">
	<input name="Cin" description="Color to split into components" type="color" default="color(0)"/>
	<output name="x" description="1st component" type="float"/>
	<output name="y" description="2nd component" type="float"/>
	<output name="z" description="3rd component" type="float"/>
	<rsl_code>
		$(x) = comp( $(Cin), 0 );
		$(y) = comp( $(Cin), 1 );
		$(z) = comp( $(Cin), 2 );
	</rsl_code>
	<usage>Gets the components of a color type variable.</usage>
</shrimp>

<shrimp type="function" name="Luminance" description="Gets the luminance value of a color" author="rconstruct">
	<input name="Cin" description="The input color" type="color" default="color(.6, .2, .1)"/>
	<output name="value" description="The luminance value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = luminance( $(Cin) );
	</rsl_code>
<usage>This blocks returns the luminance value of a color.</usage>
</shrimp>

<shrimp type="function" name="Mix" description="Performs a linear blend between A and B" author="rconstruct">
	<input name="weight" description="The mixing factor" type="color normal point vector float" default="0.5"/>
	<input name="A" description="1st Input" type_parent="value" type="color normal point vector float" default="0"/>
	<input name="B" description="2nd Input" type_parent="value" type="color normal point vector float" default="1"/>
	<output name="value" description="The resulting mix between A and B" type="color normal point vector float"/>
	<rsl_code>
		$(value) = mix( $(A), $(B), $(weight) );
	</rsl_code>
<usage>Mix returns x*(1-a)+y*a, that is, it performs a linear blend between values A and B. The types of A and B must be identical, but may be any of float, point, vector, normal, or color. The variants that operate on colors or point-like objects operate on a component by component basis (e.g: separately for x, y, and z).</usage>
</shrimp>

<shrimp type="function" name="SetCol" description="Set the components of a color" author="rconstruct">
	<input name="x" description="1st component" type="float" default="0"/>
	<input name="y" description="2nd component" type="float" default="0"/>
	<input name="z" description="3rd component" type="float" default="0"/>
	<output name="Cout" description="Color output" type="color"/>
	<rsl_code>
		setcomp( $(Cout), 0, $(x) );
		setcomp( $(Cout), 1, $(y) );
		setcomp( $(Cout), 2, $(z) );
	</rsl_code>
	<usage>Sets the components of a color type variable.</usage>
</shrimp>

<shrimp type="function" name="ToGrayscale" description="Converts color to grayscale" author="rconstruct">
	<input name="Cin" description="The input color" type="color" default="color(.6, .2, .1)"/>
	<input name="graymode" description="Conversion mode" storage="uniform" type="string" default="&quot;channel&quot;"/>
	<input name="channel" description="Optional channel to use" storage="uniform" type="float" default="0"/>
	<output name="value" description="The luminance value" type="float"/>
	<rsl_include>rsl_texture.h</rsl_include>
	<rsl_code>
		$(value) = tograyscale( $(Cin), $(graymode), $(channel) );
	</rsl_code>
<usage>This blocks converts a color to grayscale with the methods defined in the variable &quot;graymode&quot;, specifically: &quot;minimum&quot;, &quot;maximum&quot; and &quot;average&quot; in which the grayscale value is built with the minimum, maximum or average of the color&apos;s components respectively; &quot;luminance&quot;, in which the grayscale value is built from the CIE luminance function; &quot;channel&quot;, in which the grayscale value uses the color channel specified in the &quot;channel&quot; variable. If no conversion mode is specified, it defaults to &quot;luminance&quot;.</usage>
</shrimp>

<shrimp type="function" name="VaryEach" description="Larry Gritz&apos;s VaryEach" author="rconstruct">
	<input name="Cin" description="Input color" type="color" default="color(0.5)"/>
	<input name="index" description="Index" type="float" default="1"/>
    <input name="varyhue" description="Hue variation" type="float" default="1"/>
    <input name="varysat" description="Saturation variation" type="float" default="1"/>
    <input name="varylum" description="Luminance variation" type="float" default="1"/>
	<output name="value" description="The resulting color" type="color"/>
    <rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = varyEach(	$(Cin), $(index), $(varyhue),
							$(varysat), $(varylum) );
	</rsl_code>
<usage>Larry Gritz&apos;s VaryEach takes a computed color, then tweaks each indexed item separately to add some variation. Hue, saturation and lightness are all independently controlled. Hue adds, but saturation and lightness multiply.</usage>
</shrimp>

<shrimp type="function" name="Color2Float" description="Averages color to float" author="rconstruct">
    <input name="in" description="Input color" type="color" default="color(1)"/>
    <output name="value" description="Output value" type="float"/>
	<rsl_code>
	    $(value) = (comp( $(in),0)+comp( $(in),1)+comp( $(in),2)) / 3;
	</rsl_code>
	<usage>Averages a color input into a float output.</usage>
</shrimp>

<shrimp type="function" name="Color2Normal" description="Color to normal conversion" author="rconstruct">
    <input name="in" description="Input color" type="color" default="color(0)"/>
    <output name="value" description="Output value" type="normal"/>
	<rsl_code>
	    $(value) = normal( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a normal with a color&apos;s components, so the resulting normal will be in [0,1] range.</usage>
</shrimp>

<shrimp type="function" name="Color2Point" description="Color to point conversion" author="rconstruct">
    <input name="in" description="Input color" type="color" default="color(0)"/>
    <output name="value" description="Output value" type="point"/>
	<rsl_code>
	    $(value) = point( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a point with a color&apos;s components, the resulting point being in the [0,1] range.</usage>
</shrimp>

<shrimp type="function" name="Color2Vector" description="Color to vector conversion" author="rconstruct">
    <input name="in" description="Input color" type="color" default="color(0)"/>
    <output name="value" description="Output value" type="vector"/>
	<rsl_code>
	    $(value) = vector( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a vector with a color&apos;s components, the resulting vector being in the [0,1] range.</usage>
</shrimp>

<shrimp type="function" name="Normal2Color" description="Normal to color conversion" author="rconstruct">
    <input name="in" description="Input value" type="normal" default="normal(0)"/>
    <output name="value" description="Output value" type="color"/>
	<rsl_code>
		$(value) = color( $(in) * normal(.5) + normal(.5) );
	</rsl_code>
	<usage>Sets a color with a normal rescaled to the [0,1] range (assuming the normal vector is normalized).</usage>
</shrimp>

<shrimp type="function" name="Normal2Point" description="Normal to point conversion" author="rconstruct">
    <input name="in" description="Input value" type="normal" default="normal(0)"/>
    <output name="value" description="Output value" type="point"/>
	<rsl_code>
	    $(value) = point( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a point with a normal&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="Normal2Vector" description="Normal to vector conversion" author="rconstruct">
    <input name="in" description="Input value" type="normal" default="normal(0)"/>
    <output name="value" description="Output value" type="vector"/>
	<rsl_code>
	    $(value) = vector( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a vector with a normal&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="Point2Color" description="Point to color conversion" author="rconstruct">
    <input name="in" description="Input value" type="point" default="point(0)"/>
    <output name="value" description="Output value" type="color"/>
	<rsl_code>
		$(value) = color( normalize(vector( $(in) ) ) * vector(.5)+vector(.5));
	</rsl_code>
	<usage>Sets a color with a point&apos;s components, after remapping the point to the [0,1] range. Point space is whatever the space of the point being passed as argument.</usage>
</shrimp>

<shrimp type="function" name="Point2Normal" description="Point to normal conversion">
    <input name="in" description="Input value" type="point" default="point(0)"/>
    <output name="value" description="Output value" type="normal"/>
	<rsl_code>
	    $(value) = normal( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a normal with a point&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="Point2Vector" description="Point to vector conversion">
    <input name="in" description="Input value" type="point" default="point(0)"/>
    <output name="value" description="Output value" type="vector"/>
	<rsl_code>
	    $(value) = vector( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a vector with a point&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="Vector2Color" description="Vector to color conversion" author="rconstruct">
    <input name="in" description="Input value" type="vector" default="vector(0)"/>
    <output name="value" description="Output value" type="color"/>
	<rsl_code>
	    $(value) = color( $(in) * vector(.5) + vector(.5) );
	</rsl_code>
	<usage>Sets a color with a vector rescaled to the [0,1] range (assuming the vector is normalized).</usage>
</shrimp>

<shrimp type="function" name="Vector2Normal" description="Vector to normal conversion" author="rconstruct">
    <input name="in" description="Input value" type="vector" default="vector(0)"/>
    <output name="value" description="Output value" type="normal"/>
	<rsl_code>
	    $(value) = normal( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a normal with a vector&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="Vector2Point" description="Vector to point conversion" author="rconstruct">
    <input name="in" description="Input value" type="vector" default="vector(0)"/>
    <output name="value" description="Output value" type="point"/>
	<rsl_code>
	    $(value) = point( comp( $(in), 0), comp( $(in), 1), comp( $(in), 2) );
	</rsl_code>
	<usage>Sets a point with a vector&apos;s components.</usage>
</shrimp>

<shrimp type="function" name="ShowDuDv" description="Show UV derivatives" author="rconstruct">
	<input name="duscale" description="Du scale factor" type="float" default="5"/>
	<input name="dvscale" description="Dv scale factor" type="float" default="5"/>
	<output name="Ci" description="Output value" type="color"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
        $(Ci) = color(	filterwidth(u) * $(duscale),
						filterwidth(v) * $(dvscale), .1 );
	</rsl_code>
	<usage>Show UV derivatives.</usage>
</shrimp>

<shrimp type="function" name="ShowFacing" description="Show orientation of surface" author="rconstruct">
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<output name="Ci" description="Output value" type="color"/>
	<rsl_code>
		$(Ci) = mix( color( 0, 1, 0), color(1, 0, 0),
						step( 0, $(VV).$(NN)) ) * 0.5 *
						diffuse( faceforward( $(NN), $(VV) ));
	</rsl_code>
<usage>Shows forward or backward facing surfaces - displays as green for forward facing, and red for backward facing. Output is multiplied by diffuse(Nf), to give an idea of the surface shape.</usage>
</shrimp>

<shrimp type="function" name="ShowGrid" description="Show micropolygon grid" author="rconstruct">
	<output name="Ci" description="Output value" storage="varying" type="color"/>
	<rsl_code>
		uniform color $(blockname)_gridcolor = color(	random(), random(),
														random() );
		$(Ci) = ( (0.8 * abs( faceforward( normalize(N), normalize(I)).
					normalize(I))) + 0.2) * $(blockname)_gridcolor;
	</rsl_code>
	<usage>Shows a random color on each micropolygon grid. It&apos;s multiplied by a facing ratio factor for increased visibility.</usage>
</shrimp>

<shrimp type="function" name="ShowNormals" description="Show surface normals" author="rconstruct">
	<input name="cspace" description="Coordinate space" storage="uniform" type="string" default="&quot;object&quot;"/>
	<input name="crange" description="Mapping to range [0,1] on/off" storage="uniform" type="float" default="1"/>
	<output name="Ci" description="Output value" type="color"/>
	<rsl_code>
	#define $(blockname)_$(crange)
	#ifdef $(blockname)_1
        $(Ci) = color( normalize( ntransform( $(cspace), N )) * 0.5 + 0.5 );
	#else
		$(Ci) = color( normalize( ntransform( $(cspace), N)) );
	#endif
	#undef $(blockname)_$(crange)
	</rsl_code>
	<usage>Displays surface normals in RGB color. CSpace allows you to choose the coordinate space, which defaults to &quot;object&quot;, and crange if set to 1 remaps the output into the [0,1] range, otherwise the output is in [-1,1] range.</usage>
</shrimp>

<shrimp type="function" name="ShowST" description="Show ST coordinates" author="rconstruct">
	<output name="Ci" description="Output value" storage="varying" type="color"/>
	<rsl_code>
        $(Ci) = color( s, t, .1 );
	</rsl_code>
	<usage>Shows the surface&apos;s ST texture coordinates as a color, with the resulting color components being R=S, G=T, and B=0.1.</usage>
</shrimp>

<shrimp type="function" name="ShowUV" description="Show UV parameters" author="rconstruct">
	<output name="Ci" description="Output value" storage="varying" type="color"/>
	<rsl_code>
        $(Ci) = color( u, v, .1 );
	</rsl_code>
	<usage>Shows the surface&apos;s UV parameters as a color, with the color&apos;s components being R=U, G=V, B=0.1.</usage>
</shrimp>

<shrimp type="function" name="Cell1D" description="1 dimensional cell noise function" author="rconstruct">
	<input name="x" description="value to sample noise at" storage="varying" type="float" default="s"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Cell noise value at x" type="color vector point float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) cellnoise( $(x) );
	</rsl_code>
	<usage>Cellnoise returns a random value between 0 and &quot;amplitude&quot; for each integer &quot;cell&quot;. It&apos;s much cheaper than calling noise.</usage> 
</shrimp>

<shrimp type="function" name="Cell2D" description="2 dimensional cell noise function" author="rconstruct">
	<input name="s" description="noise x co-ordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="noise y co-ordinate" storage="varying" type="float" default="t"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Cell noise value at (x,y)" type="color vector point float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) cellnoise( $(s), $(t) );
	</rsl_code>
	<usage>Cellnoise returns a random value between 0 and &quot;amplitude&quot; for each integer &quot;cell&quot;. It&apos;s much cheaper than calling noise.</usage> 
</shrimp>

<shrimp type="function" name="Cell3D" description="3 dimensional cell noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Cell noise value at point p" type="color vector point float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) cellnoise( $(P) );
	</rsl_code>
	<usage>Cellnoise returns a random value between 0 and &quot;amplitude&quot; for each integer &quot;cell&quot;. It&apos;s much cheaper than calling noise.</usage> 
</shrimp>

<shrimp type="function" name="Cell4D" description="4 dimensional cell noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Cell noise value at point (P,t)" type="color vector point float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) cellnoise( $(P), $(w) );
	</rsl_code>
	<usage>Cellnoise returns a random value between 0 and &quot;amplitude&quot; for each integer &quot;cell&quot;. It&apos;s much cheaper than calling noise. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage> 
</shrimp>

<shrimp type="function" name="FNoise1D" description="Filtered 1 dimensional Perlin noise function" author="rconstruct">
	<input name="x" description="value to sample noise at" type="float" default="s"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at x" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * $(value:type) filterednoise( $(x),
		$(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvnoise( $(x),
		$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered 1 dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="FNoise2D" description="Filtered 2 dimensional perlin noise function" author="rconstruct">
	<input name="s" description="noise x co-ordinate" type="float" default="s"/>
	<input name="t" description="noise y co-ordinate" type="float" default="t"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type) 1
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * $(value:type) filterednoisexy( $(s), $(t),
												$(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvnoisexy( $(s), $(t),
												$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered two dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="FNoise3D" description="Filtered 3 dimensional perlin noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * $(value:type) filterednoise(
					$(P), $(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvnoise(
					$(P), $(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered three dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="FNoise4D" description="Filtered 4 dimensional perlin noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point (p,t)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * $(value:type) filterednoisexy( $(P), $(w),
												$(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvnoisexy( $(P), $(w),
												$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
<usage>Filtered four dimensional Perlin noise function. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform. Output value is in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="Noise1D" description="1 dimensional perlin noise function" author="rconstruct">
	<input name="x" description="value to sample noise at" storage="varying" type="float" default="s"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at x" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) noise( $(x) );
	</rsl_code>
	<usage>1 dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="Noise2D" description="2 dimensional perlin noise function" author="rconstruct">
	<input name="s" description="noise x co-ordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="noise y co-ordinate" storage="varying" type="float" default="t"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) noise( $(s), $(t) );
	</rsl_code>
	<usage>2 dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="Noise3D" description="3 dimensional perlin noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point p" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) noise( $(P) );
	</rsl_code>
	<usage>3 dimensional Perlin noise function, in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="Noise4D" description="4 dimensional perlin noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point (p,t)" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) noise( $(P), $(w) );
	</rsl_code>
	<usage>4 dimensional Perlin noise function. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform. Output value is in [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="PNoise1D" description="1 dimensional periodic noise function" author="rconstruct">
	<input name="x" description="Value to sample noise at" storage="varying" type="float" default="s"/>
	<input name="period" description="Noise period" storage="uniform" type="float" default="5"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at x" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) pnoise( $(x), $(period) );
	</rsl_code>
<usage>1 dimensional periodic noise function. Period should be an integer up to 256. Output value is in the [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="PNoise2D" description="2 dimensional periodic noise function" author="rconstruct">
	<input name="s" description="noise x co-ordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="noise y co-ordinate" storage="varying" type="float" default="t"/>
	<input name="xperiod" description="X period" storage="uniform" type="float" default="5"/>
	<input name="yperiod" description="Y period" storage="uniform" type="float" default="5"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) pnoise( $(s), $(s),
							$(xperiod), $(yperiod) );
	</rsl_code>
<usage>2 dimensional periodic noise function. XY periods should be integers up to 256. Output value is in the [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="PNoise3D" description="3 dimensional periodic noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="Pperiod" description="Point period" storage="uniform" type="point" default="point(5)"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point p" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) pnoise( $(P), $(Pperiod) );
	</rsl_code>
<usage>3 dimensional periodic noise function. Point period should be integer up to 256. Output value is in the [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="PNoise4D" description="4 dimensional periodic noise function" author="rconstruct">
	<input name="P" description="point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="Pperiod" description="Point period" storage="uniform" type="point" default="point(5)"/>
	<input name="wperiod" description="4d period" storage="uniform" type="float" default="1"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at point (p,t)" type="color point vector float"/>
	<rsl_code>
		$(value) = $(amplitude) * $(value:type) pnoise( $(P), $(w),
									$(Pperiod), $(wperiod) );
	</rsl_code>
<usage>4 dimensional period noise function. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform. Both the point period and the 4th dimension variable period should be integers up to 256. The noise output value is in the [0, &quot;amplitude&quot;] range.</usage>
</shrimp>

<shrimp type="function" name="Ridged1D" description="1 dimensional Ridged multi-fractal." author="rconstruct">
	<input name="x" description="Value to sample fractal at" storage="varying" type="float" default="s"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap between successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fractal" type="float" default="0.5"/>
	<input name="offset" description="Controls the multifractality" type="float" default="0.7"/>
	<input name="amplitude" description="Amplitude of fractal" type="float" default="1"/>
	<output name="value" description="Fractal value at x" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * Ridged( $(x), $(filterwidth), $(octaves),
										$(lacunarity), $(offset), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vRidged( $(x),
			$(filterwidth), $(octaves), $(lacunarity), $(offset), $(gain)));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 1 dimensional Ridged Multifractal function. Note that offset can change the scale of the output drastically.</usage> 
</shrimp>

<shrimp type="function" name="Ridged2D" description="2 dimensional Ridged multi-fractal." author="rconstruct">
	<input name="s" description="x co-ordinate to sample fractal at" storage="varying" type="float" default="s"/>
	<input name="t" description="y co-ordinate to sample fractal at" storage="varying" type="float" default="t"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap between successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fractal" type="float" default="0.5"/>
	<input name="offset" description="Controls the multifractality" type="float" default="0.7"/>
	<input name="amplitude" description="Amplitude of fractal" type="float" default="1"/>
	<output name="value" description="fractal value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * Ridged( $(s), $(t), $(filterwidth),
					$(octaves), $(lacunarity),$(offset), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vRidged( $(s), $(t),
			$(filterwidth), $(octaves), $(lacunarity), $(offset), $(gain)));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 2 dimensional Ridged Multifractal function. Note that offset can change the scale of the output drastically.</usage>
</shrimp>

<shrimp type="function" name="Ridged3D" description="3 dimensional Ridged multi-fractal." author="rconstruct">
	<input name="P" description="point to sample fractal at" storage="varying" type="point" default="P"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap between successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fractal" type="float" default="0.5"/>
	<input name="offset" description="Controls the multifractality" type="float" default="0.7"/>
	<input name="amplitude" description="Amplitude of fractal" type="float" default="1"/>
	<output name="value" description="fractal value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * Ridged( $(P), $(filterwidth), $(octaves),
						$(lacunarity), $(offset), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vRidged( $(P),
			$(filterwidth), $(octaves), $(lacunarity), $(offset), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 3 dimensional Ridged Multifractal function. Note that offset can change the scale of the output drastically.</usage> 
</shrimp>

<shrimp type="function" name="Ridged4D" description="4 dimensional Ridged multi-fractal." author="rconstruct">
	<input name="P" description="point to sample fractal at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap between successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fractal" type="float" default="0.5"/>
	<input name="offset" description="Controls the multifractality" type="float" default="0.7"/>
	<input name="amplitude" description="Amplitude of fractal" type="float" default="1"/>
	<output name="value" description="fractal value at (p,t)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * Ridged( $(P), $(w), $(filterwidth),
				$(octaves), $(lacunarity), $(offset), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vRidged( $(P), $(w),
				$(filterwidth), $(octaves), $(lacunarity), $(offset), $(gain)));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 4 dimensional Ridged Multifractal function. Note that offset can change the scale of the output drastically. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage> 
</shrimp>

<shrimp type="function" name="FSNoise1D" description="1D filtered signed Perlin noise" author="rconstruct">
	<input name="x" description="Value to sample noise at" storage="varying" type="float" default="s"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at x" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredsnoise( $(x), $(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoise( $(x),
					$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered version of 1 dimensional signed noise. SNoise is exactly like Noise except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1].</usage> 
</shrimp>

<shrimp type="function" name="FSNoise2D" description="Filtered signed 2 dimensional Perlin noise function" author="rconstruct">
	<input name="s" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Noise y coordinate" storage="varying" type="float" default="t"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredsnoisexy( $(s), $(t),
					$(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoisexy( $(s), $(t),
													$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered version of 2 dimensional signed noise. SNoise is exactly like Noise except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1].</usage> 
</shrimp>

<shrimp type="function" name="FSNoise3D" description="Filtered signed 3 dimensional Perlin noise function" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
    <input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredsnoise( $(P), $(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoise( $(P),
					$(filterwidth));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered version of 3 dimensional signed noise. SNoise is exactly like Noise except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to the range [-1,1].</usage>
</shrimp>

<shrimp type="function" name="FSNoise4D" description="Filtered signed 4 dimensional Perlin noise function" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
    <input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (p,t)" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredsnoisexy( $(P), $(w),
					$(filterwidth) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoisexy( $(P),
					$(w), $(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Filtered version of 4 dimensional signed noise. SNoise is exactly like Noise except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1]. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="SNoise1D" description="1D signed Perlin noise" author="rconstruct">
	<input name="x" description="Value to sample noise at" storage="varying" type="float" default="s"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at x" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * snoise( $(x) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoise( $(x) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>1 dimensional signed noise. SNoise is exactly like Noise, except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;], rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1].</usage>
</shrimp>

<shrimp type="function" name="SNoise2D" description="Signed 2 dimensional Perlin noise function" author="rconstruct">
	<input name="s" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Noise y coordinate" storage="varying" type="float" default="t"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * snoisexy( $(s), $(t) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoisexy( $(s), $(t) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>2 dimensional signed noise. SNoise is exactly like Noise except that the result to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1].</usage>
</shrimp>

<shrimp type="function" name="SNoise3D" description="Signed 3 dimensional Perlin noise function" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * snoise( $(P) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoise( $(P) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>3 dimensional version of signed noise. SNoise is exactly like Noise except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1].</usage>
</shrimp>

<shrimp type="function" name="SNoise4D" description="Signed 4 dimensional Perlin noise function" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (p,t)" type="color point vector float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * snoisexy( $(P), $(w) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoisexy( $(P), $(w) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>4 dimensional signed noise. SNoise is exactly like Noise, except that the result defaults to the range [-&quot;amplitude&quot;,&quot;amplitude&quot;] rather than [0,&quot;amplitude&quot;]. The average value is therefore zero. The parameter &quot;amplitude&quot; defaults to 1, so the noise range defaults to [-1,1]. The 4th dimensional parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="Turbulence1D" description="1 dimensional turbulence function." author="rconstruct">
	<input name="x" description="Value to sample turbulence at" storage="varying" type="float" default="s"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap in successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the turbulence" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of turbulence" type="float" default="1"/>
	<output name="value" description="Turbulence value at x" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * turbulence( $(x), $(filterwidth), $(octaves),
					$(lacunarity), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector vturbulence( $(x),
				$(filterwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>1 dimensional turbulence fractal function with Perlin noise basis. Returns a result in the [0,1] range by default.</usage>
</shrimp>

<shrimp type="function" name="Turbulence2D" description="2 dimensional turbulence function." author="rconstruct">
	<input name="s" description="X coordinate to sample turbulence at" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate to sample turbulence at" storage="varying" type="float" default="t"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap of successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the turbulence" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of turbulence" type="float" default="1"/>
	<output name="value" description="Turbulence value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * turbulence( $(s), $(t), $(filterwidth),
					$(octaves), $(lacunarity), $(gain));
	#else
		$(value) = $(amplitude) * $(value:type) ( vector vturbulence( $(s),
				$(t), $(filterwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)

	</rsl_code>
	<usage>2 dimensional turbulence fractal function with Perlin noise basis. Returns a result in the [0,1] range by default.</usage>
</shrimp>

<shrimp type="function" name="Turbulence3D" description="3 dimensional turbulence function." author="rconstruct">
	<input name="P" description="Point to sample turbulence at" storage="varying" type="point" default="P"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap in successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the turbulence" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of turbulence" type="float" default="1"/>
	<output name="value" description="Turbulence value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * turbulence( $(P), $(filterwidth), $(octaves),
					$(lacunarity), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector vturbulence( $(P),
					$(filterwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>3 dimensional turbulence fractal function with Perlin noise basis. Returns a result in the [0,1] range by default.</usage>
</shrimp>

<shrimp type="function" name="Turbulence4D" description="4 dimensional turbulence function." author="rconstruct">
	<input name="P" description="Point to sample turbulence at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Gap in successive frequencies" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the turbulence" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of turbulence" type="float" default="1"/>
	<output name="value" description="Turbulence value at (p,t)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * turbulence( $(P), $(w), $(filterwidth),
					$(octaves), $(lacunarity), $(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector vturbulence( $(P),
				$(w), $(filterwidth), $(octaves), $(lacunarity), $(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>4 dimensional turbulence fractal function with Perlin noise basis. Returns a result in the [0,1] range by default. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="FVLNoise1D" description="Filtered 1 dimensional VLNoise function" author="rconstruct">
	<input name="x" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="width" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredVLNoise( $(x), $(width), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoise(
				filteredvsnoise( $(x), $(width) ) * $(scale) + $(x), $(width));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s filtered 1 dimensional Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="FVLNoise2D" description="Filtered 2 dimensional VLNoise function" author="rconstruct">
	<input name="s" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Noise y coordinate" storage="varying" type="float" default="t"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredVLNoisexy( $(s), $(t),
										$(filterwidth), $(scale));
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoisexy(
				filteredsnoise( $(s), $(filterwidth) ) * $(scale) + $(s),
				filteredsnoise( $(t), $(filterwidth) ) * $(scale) + $(t),
				$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 2 dimensional filtered Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="FVLNoise3D" description="Filtered 3D VLNoise" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredVLNoise( $(P), $(filterwidth),
					$(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoise(
				filteredvsnoise( $(P), $(filterwidth) ) * $(scale) + $(P),
				$(filterwidth));
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s filtered 3 dimensional Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="FVLNoise4D" description="Filtered 4D VLNoise" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4d value" storage="uniform" type="float" default="time"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="filterwidth" description="Filter width" type="float" default="0"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * filteredVLNoisexy( $(P), $(w),
											$(filterwidth), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) filteredvsnoisexy(
				filteredsnoise( $(P), $(filterwidth) ) * $(scale) + $(P),
				filteredsnoise( $(w), $(filterwidth) ) * $(scale) + $(w),
				$(filterwidth) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s filtered 4 dimensional Variable Lacunarity noise function. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="VLNoise1D" description="1 dimensional VLNoise function" author="rconstruct">
	<input name="x" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLNoise( $(x), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoise(
											vsnoise( $(x) ) * $(scale) + $(x) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 1 dimensional Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="VLNoise2D" description="2 dimensional VLNoise function" author="rconstruct">
	<input name="s" description="Noise x coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Noise y coordinate" storage="varying" type="float" default="t"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at (x,y)" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLNoisexy( $(s), $(t), $(scale));
	#else
		$(value) = $(amplitude) * $(value:type) vsnoisexy(
					snoise( $(s) ) * $(scale) + $(s),
					snoise( $(t) ) * $(scale) + $(t) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 2 dimensional Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="VLNoise3D" description="3D VLNoise" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLNoise( $(P), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoise(
					vsnoise( $(P) ) * $(scale) + $(P) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 3 dimensional Variable Lacunarity noise function.</usage>
</shrimp>

<shrimp type="function" name="VLNoise4D" description="4D VLNoise" author="rconstruct">
	<input name="P" description="Point to sample noise at" storage="varying" type="point" default="P"/>
	<input name="w" description="4D value" storage="uniform" type="float" default="time"/>
	<input name="scale" description="Scale" type="float" default="1"/>
	<input name="amplitude" description="Amplitude of noise" type="float" default="1"/>
	<output name="value" description="Noise value at p" type="color vector point float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLNoisexy( $(P), $(w), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) vsnoisexy(
					snoise( $(P) ) * $(scale) + $(P),
					snoise( $(w) ) * $(scale) + $(w) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>Ken Musgrave&apos;s 4 dimensional Variable Lacunarity noise function. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="VLfBm1D" description="1 dimensional VLfBm" author="rconstruct">
	<input name="x" description="Value to sample VLfBm at" storage="varying" type="float" default="s"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the VLfBm" type="float" default="2.17"/>
	<input name="scale" description="VL scale" type="float" default="0"/>
	<input name="gain" description="Controls the contrast of the VLfBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of VLfBm" type="float" default="1"/>
	<output name="value" description="VLfBm value at x" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLfBm( $(x), $(filterwidth),
					$(octaves), $(lacunarity),$(gain),$(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector VLvfBm( $(x),
				$(filterwidth), $(octaves), $(lacunarity),$(gain),$(scale) ) );		
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>1 dimensional Variable Lacunarity fractional Brownian motion is a sumation of noises at different frequencies, using VLNoise instead of signed noise. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="VLfBm2D" description="2 dimensional VLfBm" author="rconstruct">
	<input name="s" description="X coordinate to sample VLfBm at" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate to sample VLfBm at" storage="varying" type="float" default="t"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the VLfBm" type="float" default="2.17"/>
	<input name="scale" description="VL scale" type="float" default="1"/>
	<input name="gain" description="Controls the contrast of the VLfBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of VLfBm" type="float" default="1"/>
	<output name="value" description="VLfBm value at (x,y)" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLfBm( $(s), $(t), $(filterwidth),
						$(octaves), $(lacunarity),$(gain),$(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector VLvfBm( $(s), $(t),
					$(filterwidth), $(octaves), $(lacunarity), 
					$(gain),$(scale) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>2 dimensional Variable Lacunarity fractional Brownian motion is a sumation of noises at different frequencies, using VLNoise instead of signed noise. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="VLfBm3D" description="3 dimensional VLfBm" author="rconstruct">
	<input name="P" description="Point to sample VLfBm at" storage="varying" type="point" default="P"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the VLfBm" type="float" default="2.17"/>
	<input name="scale" description="VL scale" type="float" default="1"/>
	<input name="gain" description="Controls the contrast of the VLfBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of VLfBm" type="float" default="1"/>
	<output name="value" description="VLfBm value at p" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLfBm( $(P), $(filterwidth), $(octaves),
					$(lacunarity), $(gain), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector VLvfBm( $(P),
			$(filterwidth), $(octaves), $(lacunarity), $(gain), $(scale) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>3 dimensional Variable Lacunarity fractional Brownian motion is a sumation of noises at different frequencies, using VLNoise instead of signed noise. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="VLfBm4D" description="4 dimensional VLfBm" author="rconstruct">
	<input name="P" description="Point to sample VLfBm at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the VLfBm" type="float" default="2.17"/>
	<input name="scale" description="VL scale" type="float" default="1" />
	<input name="gain" description="Controls the contrast of the VLfBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of VLfBm" type="float" default="1"/>
	<output name="value" description="VLfBm value at (p,t)" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * VLfBm( $(P), $(w), $(filterwidth), $(octaves),
					$(lacunarity), $(gain), $(scale) );
	#else
		$(value) = $(amplitude) * $(value:type) ( vector VLvfBm( $(P), $(w),
					$(filterwidth), $(octaves), $(lacunarity),
					$(gain), $(scale) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>4 dimensional Variable Lacunarity fractional Brownian motion is a sumation of noises at different frequencies, using VLNoise instead of signed noise. Note that the output is not clamped and may exceed +1 or -1. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="Voronoi2D1F" description="2D Voronoi noise, 1 feature" author="rconstruct">
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
    <input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
	<input name="metric" description="Distance metric, see help" storage="uniform" type="float" default="2"/>
    <output name="feature" description="feature 1" storage="varying" type="float"/>
    <output name="spos" description="X position 1" storage="varying" type="float"/>
    <output name="tpos" description="Y position 1" storage="varying" type="float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
		/* initialize */
		$(feature) = 0; $(spos) = 0; $(tpos) = 0;
		voronoi_f1_2d( $(s), $(t), $(jittering), $(metric), $(feature),
					$(spos), $(tpos) );
	</rsl_code>
	<usage>2D Voronoi cell noise, 1 feature version. When &quot;metric&quot; = 0, the distance metric is Tchebychev, otherwise the distance metric = Minkowski, being &quot;metric&quot; Minkowski&apos;s P parameter, with P = 1 as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P. Note that as P increases, the metric tends towards the Tchebychev result.</usage> 
</shrimp>

<shrimp type="function" name="Voronoi2D2F" description="2D Voronoi noise, 2 features." author="rconstruct">
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
    <input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
	<input name="metric" description="Distance metric, see help" storage="uniform" type="float" default="2"/>
    <output name="feature1" description="feature 1" storage="varying" type="float"/>
    <output name="spos1" description="X position 1" storage="varying" type="float"/>
    <output name="tpos1" description="X position 1" storage="varying" type="float"/>
    <output name="feature2" description="feature 2" storage="varying" type="float"/>
    <output name="spos2" description="X position 2" storage="varying" type="float"/>
    <output name="tpos2" description="X position 2" storage="varying" type="float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
		/* initialize */
		$(feature1) = 0; $(spos1) = 0; $(tpos1) = 0;
		$(feature2) = 0; $(spos2) = 0; $(tpos2) = 0;
    	voronoi_f1f2_2d( $(s), $(t), $(jittering), $(metric),
			$(feature1), $(feature2), $(spos1), $(tpos1), $(spos2), $(tpos2));
	</rsl_code>
	<usage>2D Voronoi cell noise, 2 feature version. When &quot;metric&quot; = 0, distance metric is Tchebychev, otherwise the distance metric = Minkowski, being &quot;metric&quot;, Minkowski&apos;s P parameter, with P = 1, as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P. Note that as P increases, the metric tends towards a Tchebychev result.</usage> 
</shrimp>

<shrimp type="function" name="Voronoi3D1F" description="3D Voronoi noise, 1 feature." author="rconstruct">
	<input name="P" description="Point to sample Voronoi at" storage="varying" type="point" default="P"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
	<input name="metric" description="Distance metric, see help" storage="uniform" type="float" default="2"/>
    <output name="feature" description="Feature 1" storage="varying" type="float"/>
	<output name="Ppos" description="Position 1" storage="varying" type="point"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
		/* initialize */
		$(feature) = 0; $(Ppos) = point(0);
		voronoi_f1_3d( $(P), $(jittering), $(metric), $(feature), $(Ppos) );
	</rsl_code>
	<usage>3D Voronoi cell noise, single feature version. When &quot;metric&quot;  = 0 the distance metric is Tchebychev, otherwise the distance metric = Minkowski, being &quot;metric&quot;, Minkowski&apos;s P parameter, with P = 1, as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P. Note that as P increases, it tends towards the Tchebychev result.</usage> 
</shrimp>

<shrimp type="function" name="Voronoi3D2F" description="3D Voronoi noise, 2 features." author="rconstruct">
	<input name="P" description="Point to sample Voronoi at" storage="varying" type="point" default="P"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
	<input name="metric" description="Distanc metric, see help" storage="uniform" type="float" default="2"/>
	<output name="feature1" description="Feature 1" storage="varying" type="float"/>
	<output name="feature2" description="Feature 2" storage="varying" type="float"/>
	<output name="Ppos1" description="Position 1" storage="varying" type="point"/>
	<output name="Ppos2" description="Position 2" storage="varying" type="point"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
		/* initialize */
		$(feature1) = 0; $(Ppos1) = point(0);
		$(feature2) = 0; $(Ppos2) = point(0);
		voronoi_f1f2_3d( $(P), $(jittering), $(metric), $(feature1),
					$(feature2), $(Ppos1), $(Ppos2) );
	</rsl_code>
	<usage>3D Voronoi cell noise, 2 features version. When &quot;metric&quot; = 0, distance metric is Tchebychev otherwise the distance metric = Minkowski, being &quot;metric&quot;, Minkowski&apos;s P parameter, with P = 1 as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P. Note that as P increases, it tends towards the Tchebychev result.</usage> 
</shrimp>

<shrimp type="function" name="fBm1D" description="1 dimensional fractional Brownian motion." author="rconstruct">
	<input name="x" description="Value to sample fBm at" storage="varying" type="float" default="s"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the fBm" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of fBm" type="float" default="1"/>
	<output name="value" description="fBm value at x" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * fBm( $(x), $(filterwidth), $(octaves),
					$(lacunarity),$(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vfBm( $(x),
					$(filterwidth), $(octaves), $(lacunarity),$(gain) ) );		
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>1 dimensional fractional Brownian motion is a sumation of noises at different frequencies. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="fBm2D" description="2 dimensional fractional Brownian motion." author="rconstruct">
	<input name="s" description="X coordinate to sample fBm at" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate to sample fBm at" storage="varying" type="float" default="t"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the fBm" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of fBm" type="float" default="1"/>
	<output name="value" description="fBm value at (x,y)" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * fBm( $(s), $(t), $(filterwidth), $(octaves),
					$(lacunarity),$(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vfBm( $(s), $(t),
					$(filterwidth), $(octaves), $(lacunarity),$(gain) ) );		
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>2 dimensional fractional Brownian motion is a sumation of noises at different frequencies. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="fBm3D" description="3 dimensional fractional Brownian motion." author="rconstruct">
	<input name="P" description="Point to sample fBm at" storage="varying" type="point" default="P"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the fBm" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of fBm" type="float" default="1"/>
	<output name="value" description="fBm value at p" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * fBm( $(P), $(filterwidth), $(octaves),
					$(lacunarity),$(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vfBm( $(P),
					$(filterwidth), $(octaves),	$(lacunarity), $(gain) ) );		
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>3 dimensional fractional Brownian motion is a sumation of noises at different frequencies. Note that the output is not clamped and may exceed +1 or -1.</usage>
</shrimp>

<shrimp type="function" name="fBm4D" description="4 dimensional fractional Brownian motion." author="rconstruct">
	<input name="P" description="Point to sample fBm at" storage="varying" type="point" default="P"/>
	<input name="w" description="4th dimension value" storage="uniform" type="float" default="time"/>
	<input name="filterwidth" description="Filter width for antialiasing" type="float" default="0"/>
	<input name="octaves" description="Maximum octaves of noise" storage="uniform" type="float" default="5"/>
	<input name="lacunarity" description="Controls the smoothness of the fBm" type="float" default="2.17"/>
	<input name="gain" description="Controls the contrast of the fBm" type="float" default="0.5"/>
	<input name="amplitude" description="Amplitude of fBm" type="float" default="1"/>
	<output name="value" description="fBm value at (p,t)" type="color point vector normal float"/>
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(amplitude) * fBm( $(P), $(w), $(filterwidth), $(octaves),
					$(lacunarity),$(gain) );
	#else
		$(value) = $(amplitude) * $(value:type) (vector vfBm( $(P), $(w),
					$(filterwidth), $(octaves), $(lacunarity),$(gain) ) );
	#endif
	#undef $(blockname)_$(value:type)
	</rsl_code>
	<usage>4 dimensional fractional Brownian motion is a sumation of noises at different frequencies. Note that the output is not clamped and may exceed +1 or -1. The 4th dimension parameter defaults to the global variable &quot;time&quot;, the current shutter time as defined by RiShutter. Note that &quot;time&quot;&apos;s storage class is uniform.</usage>
</shrimp>

<shrimp type="function" name="Cartesian2Cylindrical" description="Converts Cartesian coordinates to cylindrical coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = cartesian2cylindrical( $(In) );
	</rsl_code>
	<usage>Converts Cartesian coordinates to cylindrical coordinates.</usage>
</shrimp>

<shrimp type="function" name="Cartesian2Polar2D" description="Converts 2D Cartesian coordinates to polar coordinates" author="rconstruct">
	<input name="x" description="X coordinate of point to convert" type="float" default="s"/>
	<input name="y" description="Y coordinate of point to convert" type="float" default="t"/>
	<output name="rho" description="The converted X coordinate" type="float"/>
	<output name="theta" description="The converted Y coordinate" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		cartesian2polar2d(	$(x), $(y), $(rho), $(theta) );
	</rsl_code>
	<usage>Converts 2D Cartesian coordinates to polar coordinates.</usage>
</shrimp>

<shrimp type="function" name="Cartesian2Spherical" description="Converts Cartesian coordinates to spherical coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = cartesian2spherical( $(In) );
	</rsl_code>
	<usage>Converts Cartesian coordinates to spherical coordinates.</usage>
</shrimp>

<shrimp type="function" name="Cylindrical2Cartesian" description="Converts cylindrical coordinates to Cartesian coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = cylindrical2cartesian( $(In) );
	</rsl_code>
	<usage>Converts cylindrical coordinates to Cartesian coordinates.</usage>
</shrimp>

<shrimp type="function" name="Cylindrical2Spherical" description="Converts cylindrical coordinates to spherical coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = cylindrical2spherical( $(In) );
	</rsl_code>
	<usage>Converts cylindrical coordinates to spherical coordinates.</usage>
</shrimp>

<shrimp type="function" name="Polar2Cartesian2D" description="Converts 2D polar coordinates to Cartesian coordinates" author="rconstruct">
	<input name="rho" description="X coordinate of point to convert" type="float" default="s"/>
	<input name="theta" description="Y coordinate of point to convert" type="float" default="t"/>
	<output name="x" description="The converted X coordinate" type="float"/>
	<output name="y" description="The converted Y coordinate" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		polar2cartesian2d( $(rho), $(theta), $(x), $(y) );
	</rsl_code>
	<usage>Converts 2D polar coordinates to Cartesian coordinates.</usage>
</shrimp>

<shrimp type="function" name="Spherical2Cartesian" description="Converts spherical coordinates to Cartesian coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = spherical2cartesian( $(In) );
	</rsl_code>
	<usage>Converts spherical coordinates to Cartesian coordinates.</usage>
</shrimp>

<shrimp type="function" name="Spherical2Cylindrical" description="Converts spherical coordinates to cylindrical coordinates" author="rconstruct">
	<input name="In" description="Input normal, vector or point" type_parent="value" type="normal vector point" default="point(0)"/>
	<output name="value" description="Converted normal, vector or point" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(value) = spherical2cylindrical( $(In) );
	</rsl_code>
	<usage>Converts spherical coordinates to cylindrical coordinates.</usage>
</shrimp>

<shrimp type="function" name="Area" description="Differential surface area" author="rconstruct">
	<input name="P" description="Point to compute area at" type="point" default="P"/>
	<input name="strategy" description="Strategy" storage="uniform" type="string" default="&quot;shading&quot;"/>
	<output name="value" description="Differential surface area at p" type="float"/>
	<rsl_code>
	#if RENDERER == aqsis
		$(value) = area( $(P) );
	#else
		$(value) = area( $(P), $(strategy) );
	#endif
	</rsl_code>
<usage>Returns the geometric mean of the change of &quot;P&quot; between adjacent samples in each parametric direction. It can be interpreted as the area of the microfacet if the parameter being passed is the surface point &quot;P&quot;. The &quot;strategy&quot; variable can be either &quot;shading&quot;, in which case the micropolygon area is calculated with the surface derivatives, or &quot;dicing&quot;, in which case the micropolygons area will be calculated using their geometry. If unspecified, it defaults to &quot;shading&quot;.</usage>
</shrimp>

<shrimp type="function" name="Bump" description="Bump mapping function" author="rconstruct">
	<input name="P" description="The surface point to be bumped" storage="varying" type="point" default="P"/>
	<input name="N" description="The surface normal" storage="varying" type="normal" type_parent="BumpedN" default="normalize(N)"/>
	<input name="bumpscale" description="Amplitude of the bumping" type="float" default="0.5"/>
	<output name="BumpedN" description="The new surface normal" storage="varying" type="normal"/>
	<rsl_code>
		$(BumpedN) = normalize( calculatenormal( $(P) + $(N) * $(bumpscale)));
	</rsl_code>
	<usage>This is exactly like the displace function except that the new surface position is not computed. Calculates the normal of a position &quot;P&quot; displaced by amount &quot;bumpscale&quot; in direction &quot;N&quot;.</usage>
</shrimp>

<shrimp type="function" name="CalcNormal" description="Calculate the normal at point" author="rconstruct">
	<input name = "P" description="Point to calculate normal at" storage="varying" type="point" default="P"/>
	<output name="N" description="NN is normal at p" storage="varying" type="normal"/>
	<rsl_code>
		$(N) = calculatenormal( $(P) );
	</rsl_code>
<usage>Returns the surface normal of the given point on the surface. You should always recalculate the normals after a displacement.</usage>
</shrimp>

<shrimp type="function" name="CxFresnel" description="Complex Fresnel block" author="rconstruct">
	<input name="I" description="Incident vector" type="vector" default="normalize(I)"/>
	<input name="N" description="Surface normal" type="vector normal" default="normalize(N)"/>
	<input name="ior" description="Index of refraction" type="float" default="1.5"/>
	<input name="extinction" description="Extinction coefficient" type="float" default="0.5"/>
	<output name="Kr" description="The reflected coefficient" type="float"/>
	<output name="Kt" description="The refracted coefficient" type="float"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(Kr) = fresnel_kr( -$(I).$(N), cx_set( $(ior), $(extinction) ) );
		$(Kt) = max( 0.0, 1.0 - $(Kr) );
	</rsl_code>
<usage>Complex Fresnel function using full formula for unpolarized light, returns the reflection coefficient Kr and the refraction coefficient Kt, given an incident direction I, the surface normal N, and the complex ior (ior + extinction). Based on Odforce&apos;s Odwiki article on BRDFs, and on the Odwiki&apos;s complex.h file, by the Odforce community and Mario Marengo.</usage>
</shrimp>

<shrimp type="function" name="Depth" description="Depth of point p." author="rconstruct">
	<input name = "P" description="point to test" storage="varying" type="point" default="P"/>
	<output name="value" description="The depth of point p in Camera co-ordinates" type="float"/>
	<rsl_code>
		$(value) = depth( $(P) );
	</rsl_code>
<usage>Returns the depth of the point P in &quot;camera&quot; space. The depth is normalized so that 0 is at the near clipping plane, and 1 at the far clipping plane.</usage>
</shrimp>

<shrimp type="function" name="Distance" description="Distance between 2 points" author="rconstruct">
	<input name = "Point1" description="1st point" type="point" default="P"/>
	<input name = "Point2" description="2nd point" type="point" default="point(1)"/>
	<output name="value" description="The distance between P1 and P2" type="float"/>
	<rsl_code>
		$(value) = distance( $(Point1), $(Point2) );
	</rsl_code>
	<usage>Returns the distance between two points (length(Point1-Point2)).</usage>
</shrimp>

<shrimp type="function" name="FaceForward" description="Flip a vector&apos;s direction" author="rconstruct">
	<input name="N" description="Vector or Normal to flip" storage="varying" type="vector normal" type_parent="NN" default="normalize(N)"/>
	<input name="I" description="Vector to face away from" storage="varying" type="vector" default="normalize(I)"/>
	<input name="Nref" description="Optional reference vector" type="vector normal" type_parent="NN" default="Ng"/>
	<output name="NewN" description="A vector pointing in the direction oposite to I" type="vector normal"/>
	<rsl_code>
		$(NewN) = faceforward( $(N), $(I), $(Nref) );
	</rsl_code>
	<usage>This function will flip the direction of N so that it faces a direction oposite to that of I, with respect to Nref.</usage>
</shrimp>

<shrimp type="function" name="Fresnel" description="Fresnel function" author="rconstruct">
	<input name="I" description="Incident vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="eta" description="The relative index of refraction" type="float" default="0.75"/>
	<output name="R" description="The reflected vector" type="vector"/>
	<output name="T" description="The refracted vector" type="vector"/>
	<output name="Kr" description="The reflected coefficient" type="float"/>
	<output name="Kt" description="The refracted coefficient" type="float"/>
	<rsl_code>
		/* initialize */
		$(Kr) = 0; $(Kt) = 0; $(R) = vector(0); $(T) = vector(0);
        fresnel( $(I), $(N), $(eta), $(Kr), $(Kt), $(R), $(T) );
	</rsl_code>
<usage>Return the reflection coefficient Kr and the refraction (or transmission) coefficient &quot;Kt&quot;, given an incident direction &quot;I&quot;, the surface normal &quot;N&quot;, and the relative index of refraction &quot;eta&quot;. Eta is the ratio of the index of refraction in the volume containing the incident vector, to that of the volume being entered. These coefficients are computed using the Fresnel formula. This function also returns the reflected &quot;R&quot; and transmitted &quot;T&quot; vectors.</usage>
</shrimp>

<shrimp type="function" name="GetComp" description="Get the components of a point, vector or normal" author="rconstruct">
	<input name="In" description="point, vector or normal to split into components" type="normal vector point" default="point(0)"/>
	<output name="x" description="x component" type="float"/>
	<output name="y" description="y component" type="float"/>
	<output name="z" description="z component" type="float"/>
	<rsl_code>
		$(x) = xcomp( $(In:type) $(In) );
		$(y) = ycomp( $(In:type) $(In) );
		$(z) = zcomp( $(In:type) $(In) );
	</rsl_code>
	<usage>Gets the components of a point, vector, or normal.</usage>
</shrimp>

<shrimp type="function" name="Length" description="Return the length of a vector" author="rconstruct">
	<input name = "Vin" description="Input vector" type="point normal vector" default="vector(1)"/>
	<output name="value" description="The lenght of the vector" type="float"/>
	<rsl_code>
		$(value) = length( $(Vin) );
	</rsl_code>
	<usage>Returns the length of a vector ( sqrt(Vin.Vin) ).</usage>
</shrimp>

<shrimp type="function" name="Normalize" description="Normalize a vector" author="rconstruct">
	<input name="Vin" description="Input vector" type="vector normal" type_parent="value" default="N"/>
	<output name="value" description="Output unit length vector" type="vector normal"/>
	<rsl_code>
		$(value) = normalize( $(Vin) );
	</rsl_code>
	<usage>Returns a unit vector in the direction of input vector (Vin/length(Vin)).</usage>
</shrimp>

<shrimp type="function" name="PtLineD" description="Shortest distance between a point and a line segment" author="rconstruct">
	<input name = "P" description="point to test" type="point" default="P"/>
	<input name = "Endpoint1" description="1st line endpoint" type="point" default="point(0)"/>
	<input name = "Endpoint2" description="2nd line endpoint" type="point" default="point(1)"/>
	<output name="value" description="The minimum distance between P and the line segment Endpoint1 to Endpoint2" type="float"/>
	<rsl_code>
		$(value) = ptlined( $(P), $(Endpoint1), $(Endpoint2) );
	</rsl_code>
	<usage>This function returns the minimum perpendicular distance between the point &quot;P&quot; and the line segment defined by &quot;Endpoint1&quot; and &quot;Endpoint2&quot;.</usage>
</shrimp>

<shrimp type="function" name="Reflect" description="Reflected vector" author="rconstruct">
	<input name="I" description="Incident vector" type="vector" default="normalize(I)"/>
	<input name="N" description="Surface normal" type="vector normal" default="normalize(N)"/>
	<output name="R" description="The reflected vector" type="vector"/>
	<rsl_code>
		$(R) = reflect( $(I), $(N) );
	</rsl_code>
<usage>Returns the vector &quot;I&quot; reflected about the unit length normal &quot;N&quot;. It&apos;s equivalent to: I-2*(N.I)*N.</usage>
</shrimp>

<shrimp type="function" name="Refract" description="Refracted vector" author="rconstruct">
	<input name="I" description="Incident vector" type="vector" default="normalize(I)"/>
	<input name="N" description="Surface normal" type="vector normal" default="normalize(N)"/>
	<input name="eta" description="The ratio of medium IORs, see usage." type="float" default="0.75"/>
	<output name="T" description="The refracted vector" type="vector"/>
	<rsl_code>
		$(T) = refract( $(I), $(N), $(eta) );
	</rsl_code>
	<usage>Return the refracted vector &quot;T&quot;given an incident direction &quot;I&quot;, the normal vector &quot;N&quot;, and the relative index of refraction &quot;eta&quot;. Eta is the ratio of the index of refraction in the volume containing the incident vector, to that of the volume being entered. If the returned vector has zero length, then there is no transmitted light because of total internal reflrection.</usage>
</shrimp>

<shrimp type="function" name="Rotate2D" description="Rotates a 2d point about an origin" author="rconstruct">
	<input name="x" description="X coordinate of point to rotate" type="float" default="s"/>
	<input name="y" description="Y coordinate of point to rotate" type="float" default="t"/>
	<input name="ox" description="X coordinate of rotation center" type="float" default="0.5"/>
	<input name="oy" description="Y coordinate of rotation center" type="float" default="0.5"/>
	<input name="angle" description="The rotation angle in radians" type="float" default="1"/>
	<output name="rx" description="X coordinate of rotated point" type="float"/>
	<output name="ry" description="Y coordinate of rotated point" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		rotate2d( $(x), $(y), $(angle), $(ox), $(oy), $(rx), $(ry) );
	</rsl_code>
	<usage>Rotates the point (&quot;x&quot;,&quot;y&quot;) &quot;angle&quot; radians about the point (&quot;ox&quot;,&quot;oy&quot;).</usage>
</shrimp>

<shrimp type="function" name="Rotate3D" description="Rotates a point about an axis" author="rconstruct">
	<input name="Q" description="point to rotate" type="point" default="P"/>
	<input name="angle" description="The angle to rotate in radians" type="float" default="1"/>
	<input name="P1" description="1st line endpoint" type="point" default="point(0)"/>
	<input name="P2" description="2nd line endpoint" type="point" default="point(1)"/>
	<output name="value" description="Rotated point" type="point"/>
	<rsl_code>
		$(value) = rotate( $(Q), $(angle), $(P1), $(P2) );
	</rsl_code>
	<usage>Rotates the point &quot;Q&quot; by &quot;angle&quot; radians about the axis through points &quot;P1&quot; and &quot;P2&quot;.</usage>
</shrimp>

<shrimp name="Schlick_Fresnel" type="function" description="Shlick fresnel approximation" author="rconstruct">
	<input name="ior" description="Index of refraction" type="float" default="1.5"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<input name="V" description="Direction of viewer" storage="varying" type="vector" default="-normalize(I)"/>
	<output name="Kr" description="Reflection amount" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(Kr) = schlickfresnel( $(N), $(V), $(ior) );
	</rsl_code>
	<usage>Christophe Schlick&apos;s fast Fresnel approximation function. This function fails to model the reflectance when the ior of the medium in which the ray travels is higher than the ior of the medium the ray is about to refract into, and doesn't takes into account total internal reflection.</usage>
</shrimp>

<shrimp type="function" name="SetComp" description="Set the components of a point, vector or normal" author="rconstruct">
	<input name="x" description="X component" type="float" default="0"/>
	<input name="y" description="Y component" type="float" default="0"/>
	<input name="z" description="Z component" type="float" default="0"/>
	<output name="value" description="Point, vector, or normal with the specified components" type="point vector normal"/>
	<rsl_code>
		$(value) = $(value:type) ( $(x), $(y), $(z) ); 
	</rsl_code>
	<usage>Sets the X, Y, and Z components of a point, vector, or normal.</usage>
</shrimp>

<shrimp type="function" name="SetXcomp" description="Sets the X component of a point, vector or normal" author="rconstruct">
	<input name="x" description="X component value" type="float" default="0"/>
	<input name="Vin" description="Point, vector or normal" type_parent="value" type="normal point vector" default="vector(0)"/>
	<output name="value" description="Resulting point, vector or normal." type="normal point vector"/>
	<rsl_code>
		setxcomp( $(Vin:type) $(Vin), $(x) );
		$(value) = $(Vin);
	</rsl_code>
	<usage>Sets the X component of a point, vector, or normal.</usage>
</shrimp>

<shrimp type="function" name="SetYcomp" description="Sets the Y component of a point, vector or normal" author="rconstruct">
	<input name="y" description="Y component value" type="float" default="0"/>
	<input name="Vin" description="Point, vector or normal" type_parent="value" type="normal point vector" default="vector(0)"/>
	<output name="value" description="Resulting point, vector or normal" type="normal point vector"/>
	<rsl_code>
		setycomp( $(Vin:type) $(Vin), $(y) );
		$(value) = $(Vin);
	</rsl_code>
	<usage>Sets the Y component of a point, vector, or normal.</usage>
</shrimp>

<shrimp type="function" name="SetZcomp" description="Set the Z components of a point, vector or normal" author="rconstruct">
	<input name="z" description="Z component value" type="float" default="0"/>
	<input name="Vin" description="Point, vector or normal" type_parent="value" type="normal point vector" default="vector(0)"/>
	<output name="value" description="Resulting point, vector or normal." type="normal point vector"/>
	<rsl_code>
		setzcomp( $(Vin:type) $(Vin), $(z) );
		$(value) = $(Vin);
	</rsl_code>
	<usage>Sets the Z component of a point, vector, or normal.</usage>
</shrimp>

<shrimp type="function" name="Transform" description="Transform to a different coordinate system" author="rconstruct">
	<input name="P" description="Point, vector or normal to transform" type="normal vector point" type_parent="Pout" default="P"/>
	<input name="from_space" description="The coordinate system to transform from" storage="uniform" type="string" default="&quot;current&quot;"/>
	<input name="to_space" description="The coordinate system to transform into" storage="uniform" type="string" default="&quot;shader&quot;"/>
	<input name="Matrix" description="Use this matrix instead of a predefined coordinate system" type="matrix" default="UND"/>
	<output name="Pout" description="The transformed point, vector or normal" type="normal vector point"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	#ifdef TRANSFORM_ARGUMENTS
	#undef TRANSFORM_ARGUMENTS
	#endif

	#define Matrix_$(Matrix)
	#ifdef Matrix_UND
		#define TRANSFORM_ARGUMENTS $(to_space)
	#else
		#define TRANSFORM_ARGUMENTS	$(Matrix)
	#endif /* Matrix_UND */

	#define $(blockname)_$(P:type) 1
	#ifdef $(blockname)_point
		$(Pout) = transform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_vector
		$(Pout) = vtransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#elif $(blockname)_normal
		$(Pout) = ntransform( $(from_space), TRANSFORM_ARGUMENTS , $(P) );
	#endif /* $(blockname)_$(P:type) */
	#undef $(blockname)_$(P:type)
	
	#undef Matrix_$(Matrix)
	#undef TRANSFORM_ARGUMENTS
	</rsl_code>
	<usage>A block for the &quot;transform&quot;, &quot;vtransform&quot; and &quot;ntransform&quot; functions, to transform the supplied point &quot;P&quot;, vector &quot;V&quot; or normal &quot;N&quot; respectively, from the coordinate system &quot;fromspace&quot; to the coordinate system &quot;tospace&quot;, with &quot;fromspace&quot; defaulting to &quot;current&quot;. Note that &quot;current&quot; is implementation specific. Predefined coordinate systems are: &quot;current&quot;, &quot;object&quot;, &quot;shader&quot;, &quot;world&quot;, &quot;camera&quot;, &quot;screen&quot;, &quot;raster&quot; and &quot;NDC&quot;. A transformation matrix might be given instead of a &quot;tospace&quot; coordinate system. User defined coordinate systems can also be refered to.</usage>
</shrimp>

<shrimp type="function" name="Xcomp" description="Get the X component of a point, vector or normal" author="rconstruct">
	<input name="Vin" description="Point, vector or normal to retrieve component from" type="normal vector point" default="point(1)"/>
	<output name="x" description="X component" type="float"/>
	<rsl_code>
		$(x) = xcomp( $(Vin:type) $(Vin) );
	</rsl_code>
	<usage>Get the X component of an point, vector or normal.</usage>
</shrimp>

<shrimp type="function" name="Ycomp" description="Get the Y component of a point, vector or normal" author="rconstruct">
	<input name="Vin" description="Point, vector or normal to retrieve component from" type="normal vector point" default="point(1)"/>
	<output name="y" description="Y component" type="float"/>
	<rsl_code>
		$(y) = ycomp( $(Vin:type) $(Vin) );
	</rsl_code>
	<usage>Get the Y component of an point, vector or normal.</usage>
</shrimp>

<shrimp type="function" name="Zcomp" description="Get the Z component of a point, vector or normal" author="rconstruct">
	<input name="Vin" description="Point, vector or normal to retrieve component from" type="normal vector point" default="point(1)"/>
	<output name="z" description="Z component" type="float"/>
	<rsl_code>
		$(z) = zcomp( $(Vin:type) $(Vin) );
	</rsl_code>
	<usage>Get the Z component of an point, vector or normal.</usage>
</shrimp>

<shrimp name="BrushedVector" type="function" description="Get vector for brushed metal" author="rconstruct">
	<input name="swirls" description="Multiples of swirls per unit" type="float" default="3"/>
	<input name="noisescale" description="Scale of noise" type="float" default="1.5"/>
	<input name="twist" description="Anisotropy rotation in radians" type="float" default="0"/>
	<input name="s" description="S texture coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="T texture coordinate" storage="varying" type="float" default="t"/>
	<input name="N" description="Normalized surface normal" type="normal" default="normalize(N)"/>
	<output name="bvector" description="Brushed vector" storage="varying" type="vector"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
        $(bvector) = getbrushedvec( $(swirls), $(noisescale), $(twist),
									$(s), $(t), $(N) );
	</rsl_code>
    <usage>This block returns a brushed vector, to create anisotropic brushed metal like effects. Its parameters are &quot;swirls&quot; which controls the multiples of swirls per unit; &quot;noisescale&quot; which controls the scale of the noise that randomizes the location of the swirls, with 0 being a perfect grid; &quot;twist&quot; being the anisotropy rotation angle in radians; &quot;s&quot; and &quot;t&quot; the ST texture coordinates. This block was based on the tooledsteel.sl shader by Ivan DeWolff, from The RenderMan Repository.</usage>
</shrimp>

<shrimp type="function" name="Coordsys" description="Predefined oordinate systems" author="rconstruct">
	<output name="current" description="Current coordinate system, see help." storage="uniform" type="string"/>
	<output name="object" description="Object coordinate system, see help." storage="uniform" type="string"/>
	<output name="shader" description="Shader coordinate system, see help." storage="uniform" type="string"/>
	<output name="world" description="World coordinate system, see help." storage="uniform" type="string"/>
	<output name="camera" description="Camera coordinate system, see help." storage="uniform" type="string"/>
	<output name="screen" description="Screen coordinate system, see help." storage="uniform" type="string"/>
	<output name="raster" description="Raster coordinate system, see help." storage="uniform" type="string"/>
	<output name="NDC" description="NDC coordinate system, see help." storage="uniform" type="string"/>
	<rsl_code>
	$(current) = "current";
	$(object) = "object";
	$(shader) = "shader";
	$(world) = "world";
	$(camera) = "camera";
	$(screen) = "screen";
	$(raster) = "raster";
	$(NDC) = "NDC";
	</rsl_code>
	<usage>A simple reference block that outputs all predefined coordinate systems: &quot;current&quot;, the default coordinate system; &quot;object&quot; , the coordinate system in which the primitive is declared; &quot;shader&quot;, the coordinate system in which the shader is declared; &quot;world&quot;, the coordinate system active at RiWorldBegin; &quot;camera&quot;, the coordinate system of the camera with the positive z pointing forward, positive x pointing to the right, and positive y pointing up; &quot;screen&quot;, a perspective corrected coordinate system of the camera&apos;s image plane, with range defined by RiScreenWindow; &quot;raster&quot;, the 2D projected space of the image, with upper-left corner of the image as 0,0, and xy increasing towards their maximum values as specified by RiFormat; &quot;NDC&quot;, the Normalized Device Coordinates. Like &quot;raster&quot; space, but x and y goes from 0 to 1 across the whole image, in other words: NDC(x) = raster(x) / Xres and NDC(y) = raster(y) / Yres.</usage>
</shrimp>

<shrimp name="HairOcclusion" type="function" description="Hair Occlusion" author="rconstruct">
	<input name="rootPos" description="Hair root position primvar" storage="uniform" type="point" default="P" />
	<input name="rootNormal" description="Hair root normal primvar" storage="uniform" type="normal" default="N" />
	<input name="maxHeight" description="Hair maximum height" storage="varying" type="float" default="1" />
	<input name="samples" description="Occlusion samples" storage="uniform" type="float" default="8" />
	<input name="coneangle" description="Cone angle in radians" storage="uniform" type="float" default="PI/2" />
	<input name="density" description="Material density" storage="varying" type="float" default="1" />
	<input name="In" description="Viewer vector" type="vector" default="normalize(I)" />
	<output name="occlusion" description="Ambient occlusion" storage="varying" type="float" />
	<output name="shadowing" description="Shadowing amount" storage="varying" type="float" />
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		vector $(blockname)_Vf = -$(In);
		extern normal Ng;
		extern point P;
		normal $(blockname)_Ngn = normalize(Ng);
		
		// rootPos,rootNormal,maxHeight should be via RIB primitive variables
		point $(blockname)_Proot = $(rootPos);
		normal $(blockname)_Ngl = normalize( $(rootNormal) );
		float $(blockname)_currHeight = $(blockname)_Ngl.(P-$(blockname)_Proot);
		float $(blockname)_dgl = 1 - $(blockname)_currHeight / $(maxHeight);
		
		// calculate the ambient occlusion
		$(occlusion) = calculateNeulanderVanDePanneOcclusion(
							$(blockname)_Ngl, $(blockname)_dgl, $(density),
							vector( $(blockname)_Ngn ), $(samples),
							$(coneangle) );
		
		// calculate the shadow term from a light with direction L
		$(shadowing) = calculateNeulanderVanDePanneOcclusion(
							$(blockname)_Ngl, $(blockname)_dgl, $(density),
							vector( $(blockname)_Ngn), 1, 0 );
	</rsl_code>
    <usage>Luke Emrose&apos;s implementation of the Ivan Neulander and Michiel van de Panne&apos;s paper, &quot;Rendering Generalized Cylinders with Paintstrokes&quot;. The variables &quot;rootPos&quot;, &quot;rootNormal&quot; and &quot;maxHeight&quot;, for the hair&apos;s root position, root normal, and maximum height respectively, should be passed via primitive variables from the geometry. The variables &quot;samples&quot;, &quot;coneangle&quot; are the number of occlusion samples used and the cone angle in radians respectively (which defaults to PI/2), while &quot;density&quot; is the material density. This block outputs the hair ambient occlusion and a shadowing term.</usage>
</shrimp>

<shrimp type="function" name="MPCurvature" description="Matthew Parrot&apos;s surface curvature function" author="rconstruct">
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="offset" description="Offset" type="float" default="0"/>
	<input name="gain" description="Gain" type="float" default="1.0"/>
	<output name="value" description="Curvature at P" type="color"/>
	<output name="minimum" description="Minimum curvature" type="float"/>
	<output name="maximum" description="Maximum curvature" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		mpcurvature( $(P), $(maximum), $(minimum) );
		$(value) = color "hsv" ( $(maximum) + $(minimum) * $(gain) + 
						$(offset), .8, .8 );
	</rsl_code>
	<usage>Surface curvature function, alternative implementation by Matthew Parrot, derived from the function contained in &quot;Advanced Renderman&quot; by Anthony A. Apodaca and Larry Gritz, and Mathworld. This function calculates how quickly the supplied surface point &quot;P&quot; is changing along an axis, and then compares this value to the change in the tangent of the surface and the angle which the tangent makes with the surface. The resulting curvature value is set as the &quot;hue&quot; component of the output color.</usage>
</shrimp>

<shrimp name="SCurve" type="function" description="Surface curvature" author="rconstruct">
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="minimum" description="Minimum" type="float" default="-1"/>
    <input name="maximum" description="Maximum" type="float" default="1"/>
	<input name="curvetype" description="Curvature type, see usage." storage="uniform" type="string" default="&quot;gauss&quot;"/>
    <input name="greyscale" description="Greyscale on/off" storage="uniform" type="float" default="0"/>
	<output name="value" description="Curvature output" type="color"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
        $(value) = scurvature( $(curvetype), $(minimum), $(maximum),
								$(greyscale), $(N), $(P) );
	</rsl_code>
    <usage>Surface curvature block, based on Mario Marengo&apos;s VEX implementation of a surface curvature function, based on Andreas Baerentzen&apos;s paper: &quot;On the Computation of the Principal Curvatures of Regular Surfaces&quot;. Curvature types are &quot;gauss&quot;, for Gaussian curvature; &quot;mean&quot; as the mean of curvatures; &quot;amean&quot; as the absolute mean; &quot;minimum&quot; and &quot;maximum&quot; as the minimum and maximum of curvatures. If &quot;greyscale&quot; = 1.0, then it returns the curvature intensity in greyscale, else, it returns it in color.</usage>
</shrimp>

<shrimp type="function" name="TangentMap" description="Read a tangent space normal map" author="rconstruct">
	<input name="normalmap" description="Tangent space normal map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="s" description="Texture coordinate along S" storage="varying" type="float" default="s"/>
	<input name="t" description="Texture coordinate along T" storage="varying" type="float" default="t"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<output name="NewN" description="Converted normal" storage="varying" type="normal"/>
	<rsl_include>rsl_conversion.h</rsl_include>
	<rsl_code>
		$(NewN) = tangent2object( $(normalmap), $(s), $(t), $(N) );
	</rsl_code>
	<usage>Read a tangent space normal map texture, like the ones generated from 3d sculpting applications. Uses the &quot;dPdu&quot; and &quot;dPdv&quot; parametric derivatives. The texture coordinates &quot;s&quot; and &quot;t&quot; are used only for the texture lookup. The output normal vector is already normalized.</usage>
</shrimp>

<shrimp type="function" name="alpha" description="Fractional pixel coverage" author="rconstruct">
    <output name="alpha" description="Fractional pixel coverage" storage="uniform" type="float"/>
    <rsl_code>
    $(alpha) = alpha;
    </rsl_code>
	<usage>Fractional pixel coverage. Note that this variable is exclusive of imager shaders.</usage>
</shrimp>


<shrimp type="function" name="Cl" description="Incoming light ray color" author="rconstruct">
	<output name="Cl" description="Incoming light ray color" type="color"/>
	<rsl_code>
	$(Cl) = Cl;
	</rsl_code>
	<usage>Note that you can only access the light color Cl inside &quot;illuminance&quot; statements.</usage>
</shrimp>


<shrimp type="function" name="Cs" description="Surface color" author="rconstruct">
	<output name="Cs" description="Surface color" type="color"/>
	<rsl_code>
	$(Cs) = Cs;
	</rsl_code>
	<usage>Surface color. Only available in surface shaders.</usage>
</shrimp>


<shrimp type="function" name="dPdTime" description="How the surface position P is changing per unit time" author="rconstruct">
	<output name="dPdtime" description="How the surface position P is changing per unit time" storage="varying" type="vector"/>
	<rsl_code>
	$(dPdtime) = dPdtime;
	</rsl_code>
<usage>How the surface position &quot;P&quot; is changing per unit time. Its available in surface and displacement contexts, depending on renderer&apos;s implementations.</usage>
</shrimp>


<shrimp type="function" name="dpdu" description="Surface derivative along U" author="rconstruct">
	<output name="dPdu" description="Surface derivative of point P along U" type="vector"/>
	<rsl_code>
		$(dPdu) = dPdu;
	</rsl_code>
	<usage>Surface derivative of point &quot;P&quot; along direction &quot;U&quot;. This only accesses the global variable &quot;dPdu&quot;. If you want to calculate the surface derivative of other points, use the &quot;Du&quot; block, which calls Du(input), or the &quot;Deriv&quot; block, which calculates derivative of its first argument in regard to its second argument.</usage>
</shrimp>


<shrimp name="dpdv" type="function" description="Surface derivative along V" author="rconstruct">
	<output name="value" description="Surface derivative of point P along V" type="vector"/>
	<rsl_code>
		$(value) = dPdv;
	</rsl_code>
	<usage>Surface derivative of point &quot;P&quot; along direction &quot;V&quot;. This only accesses the global variable &quot;dPdv&quot;. If you want to calculate the surface derivative of other points, use the &quot;Dv&quot; block, which calls Dv(input), or the &quot;Deriv&quot; block, which calculates the derivatives of its first argument in regard to its second argument.</usage>
</shrimp>


<shrimp type="function" name="dTime" description="The amount of time covered by this shading sample" author="rconstruct">
	<output name="dtime" description="The amount of time covered by this shading sample" storage="uniform" type="float"/>
	<rsl_code>
	$(dtime) = dtime;
	</rsl_code>
	<usage>The amount of time covered by this shading sample. It&apos;s available in all shading contexts.</usage>
</shrimp>


<shrimp type="function" name="dudv" description="Change in surface parameters" author="rconstruct">
	<output name="du" description="Change in u direction" type="float"/>
	<output name="dv" description="Change in v direction" type="float"/>
	<rsl_code>
	$(du) = du;
	$(dv) = dv;
	</rsl_code>
	<usage>The global variables &quot;du&quot; and &quot;dv&quot;, with &quot;du&quot; being the change in surface parameter &quot;u&quot; between adjacent samples being shaded, and &quot;dv&quot; the change in surface parameter &quot;v&quot; between adjacent samples being shaded. Note that the availability of these global variables in the different shading contexts is renderer specific.</usage>
</shrimp>


<shrimp type="function" name="E" description="Position of the eye" author="rconstruct">
	<output name="E" description="Position of the eye" storage="uniform" type="point"/>
	<rsl_code>
	$(E) = E;
	</rsl_code>
	<usage>Position of the eye. This global variable isn't valid for the imager context.</usage>
</shrimp>


<shrimp type="function" name="I" description="Incident ray direction" author="rconstruct">
	<output name="I" description="Incident ray direction" storage="varying" type="vector"/>
	<rsl_code>
	$(I) = I;
	</rsl_code>
	<usage>Incident ray direction. The availability of this global variable for the different shading contexts is renderer specific.</usage>
</shrimp>


<shrimp type="function" name="L" description="Incoming light direction" author="rconstruct">
	<output name="L" description="Incoming light direction" type="vector"/>
	<rsl_code>
	$(L) = L;
	</rsl_code>
	<usage>Note that you can only access the L vector inside &quot;illuminance&quot; statements in surface shaders. In light shaders, you can only access the L vector inside &quot;solar&quot; or &quot;illuminate&quot; statements.</usage>
</shrimp>


<shrimp type="function" name="N" description="Surface shading normal" author="rconstruct">
    <output name="N" description="Surface shading normal" storage="varying" type="normal"/>
    <rsl_code>
    $(N) = N;
    </rsl_code>
	<usage>Surface shading normal. The availability of this global variable in the different shading contexts is renderer specific. It&apos;s not available in imager shaders.</usage>
</shrimp>


<shrimp type="function" name="Ncomps" description="Number of color components" author="rconstruct">
	<output name="ncomps" description="Number of color components" type="float"/>
	<rsl_code>
	$(ncomps) = ncomps;
	</rsl_code>
</shrimp>


<shrimp type="function" name="Ng" description="Surface geometric normal" author="rconstruct">
	<output name="Ng" description="Surface geometric normal" type="normal"/>
	<rsl_code>
	$(Ng) = Ng;
	</rsl_code>
	<usage>Surface geometric normal. The availability of this global variable in the different shading contexts is renderer specific. It&apos;s not available in imager shaders.</usage>
</shrimp>


<shrimp type="function" name="Ol" description="Incoming light ray opacity" author="rconstruct">
	<output name="Ol" description="Incoming light ray opacity" type="color"/>
	<rsl_code>
	$(Ol) = Ol;
	</rsl_code>
	<usage>The incoming light ray opacity. Note that you can only access the light opacity Ol inside &quot;illuminance&quot; statements.</usage>
</shrimp>


<shrimp type="function" name="Os" description="Surface opacity" author="rconstruct">
	<output name="Os" description="Surface opacity" type="color"/>
	<rsl_code>
	$(Os) = Os;
	</rsl_code>
	<usage>Surface opacity global variable. Only available in surface shaders.</usage>
</shrimp>


<shrimp type="function" name="p" description="Surface position" author="rconstruct">
    <output name="P" description="Surface position" storage="varying" type="point"/>
    <rsl_code>
    $(P) = P;
    </rsl_code>
	<usage>Note that in all shading contexts, &quot;P&quot; is the surface position, the only exception being volume shaders, in which &quot;P&quot; is the light ray origin. Also note that in imager shaders, &quot;P&quot; is the position of the pixel center in raster space, with the z coordinate being 0.</usage>
</shrimp>


<shrimp type="function" name="Ps" description="Position being illuminated" author="rconstruct">
    <output name="Ps" description="Position being illuminated" storage="varying" type="point"/>
    <rsl_code>
    $(Ps) = Ps;
    </rsl_code>
	<usage>Position being illuminated. Note that this variable is only accessed in light shaders.</usage>
</shrimp>


<shrimp type="function" name="st" description="Surface texture coordinates" author="rconstruct">
    <output name="s" description="S texture coordinate" storage="varying" type="float"/>
    <output name="t" description="T texture coordinate" storage="varying" type="float"/>
    <rsl_code>
    $(s) = s;
    $(t) = t;
    </rsl_code>
	<usage>The surface texturing coordinates. The availability of these global variables in the different shading contexts is renderer specific.</usage>
</shrimp>


<shrimp type="function" name="Time" description="Current shutter time" author="rconstruct">
	<output name="time" description="Current shutter time" storage="uniform" type="float"/>
	<rsl_code>
	$(time) = time;
	</rsl_code>
	<usage>Current shutter time as specified by RiShutter. It&apos;s available in all shading contexts.</usage>
</shrimp>


<shrimp type="function" name="uv" description="Parametric surface coordinates" author="rconstruct">
    <output name="u" description="U surface coordinate" storage="varying" type="float"/>
    <output name="v" description="V surface coordinate" storage="varying" type="float"/>
    <rsl_code>
    $(u) = u;
    $(v) = v;
    </rsl_code>
	<usage>The parametric surface coordinates. The availability of these global variables in the different shading contexts is renderer specific.</usage>
</shrimp>


<shrimp type="function" name="BlendMode" description="Blends two color in user set mode" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" storage="uniform" type="float" default="0"/>
	<input name="blendmode" description="Blending mode, see info" storage="uniform" type="float" default="0"/>
	<output name="OutC" description="Blended color" type="color" />
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
		// valid range = [0,25], outside this range, 25 assumed
		uniform float bmode_$(blockname) = $(blendmode);
	#define invertmask_$(invert)
	#ifdef invertmask_0
		// choose appropriate blending mode
		if ( bmode_$(blockname) == 0) // Over
			$(OutC) = color_over( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 1) // Average
			$(OutC) = color_avg( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 2) // Add
			$(OutC) = color_add( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 3) // Subtract
			$(OutC) = color_sub( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 4) // Multiply
			$(OutC) = color_multiply( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 5) // Divide
			$(OutC) = color_divide( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 6) // Lighten
			$(OutC) = color_lighten( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 7) // Darken
			$(OutC) = color_darken( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 8) // Screen
			$(OutC) = color_screen( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 9) // Overlay
			$(OutC) = color_overlay( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 10) // Softlight
			$(OutC) = color_softlight( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 11) // SoftlightPS
			$(OutC) = color_softlightps( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 12) // Hardlight
			$(OutC) = color_hardlight( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 13) // Vividlight
			$(OutC) = color_vividlight( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 14) // Linearlight
			$(OutC) = color_linearlight( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 15) // Pinlight
			$(OutC) = color_pinlight( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 16) // Dodge
			$(OutC) = color_dodge( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 17) // Burn
			$(OutC) = color_burn( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 18) // Lineardodge
			$(OutC) = color_lineardodge( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 19) // Linearburn
			$(OutC) = color_linearburn( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 20) // Difference
			$(OutC) = color_difference( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 21) // Exclusion
			$(OutC) = color_exclusion( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 22) // Saturate
			$(OutC) = color_saturate( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 23) // Desaturate
			$(OutC) = color_desaturate( $(BkgColor), $(FrgColor), $(weight) );
		else if ( bmode_$(blockname) == 24) // Illuminate
			$(OutC) = color_illuminate( $(BkgColor), $(FrgColor), $(weight) );
		else // Reflect
			$(OutC) = color_reflect( $(BkgColor), $(FrgColor), $(weight) );
	#else // invert weight mask
		if ( bmode_$(blockname) == 0) // Over
			$(OutC) = color_over( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 1) // Average
			$(OutC) = color_avg( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 2) // Add
			$(OutC) = color_add( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 3) // Subtract
			$(OutC) = color_sub( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 4) // Multiply
			$(OutC) = color_multiply( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 5) // Divide
			$(OutC) = color_divide( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 6) // Lighten
			$(OutC) = color_lighten( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 7) // Darken
			$(OutC) = color_darken( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 8) // Screen
			$(OutC) = color_screen( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 9) // Overlay
			$(OutC) = color_overlay( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 10) // Softlight
			$(OutC) = color_softlight( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 11) // SoftlightPS
			$(OutC) = color_softlightps( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 12) // Hardlight
			$(OutC) = color_hardlight( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 13) // Vividlight
			$(OutC) = color_vividlight( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 14) // Linearlight
			$(OutC) = color_linearlight( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 15) // Pinlight
			$(OutC) = color_pinlight( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 16) // Dodge
			$(OutC) = color_dodge( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 17) // Burn
			$(OutC) = color_burn( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 18) // Lineardodge
			$(OutC) = color_lineardodge( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 19) // Linearburn
			$(OutC) = color_linearburn( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 20) // Difference
			$(OutC) = color_difference( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 21) // Exclusion
			$(OutC) = color_exclusion( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 22) // Saturate
			$(OutC) = color_saturate( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 23) // Desaturate
			$(OutC) = color_desaturate( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else if ( bmode_$(blockname) == 24) // Illuminate
			$(OutC) = color_illuminate( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
		else // Reflect
			$(OutC) = color_reflect( $(BkgColor), $(FrgColor),
			1 - clamp( $(weight), 0, 1) );
	#endif // invert mask check
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Returns a blended color between &quot;BkgColor&quot; and &quot;FrgColor&quot; with weighting factor &quot;weight&quot;, using one of the available blending modes set by &quot;blendmode&quot;. This &quot;blendmode&quot; variable should be in [0,25] range, any value outside this range is assumed to be 25.
	The blending modes follow: 0) Over; 1) Average; 2) Add; 3) Subtract; 4) Multiply; 5) Divide; 6) Lighten; 7) Darken; 8) Screen; 9) Overlay; 10) SoftLight; 11) SoftLightPS (equivalent of Photoshop&amp;s &quot;SoftLight&quot; mode); 12) Hardlight; 13) VividLight; 14) LinearLight; 15) PinLight; 16) Dodge; 17) Burn; 18) LinearDodge; 19) LinearBurn; 20) Difference; 21) Exclusion; 22) Saturate; 23) Desaturate; 24) Illuminate; 25) Reflect.
	Note that some blending modes are commutative, the order of the inputs can be swapped, but other blend modes, such as &quot;Hardlight&quot;, &quot;Overlay&quot;, &quot;VividLight&quot;, &quot;LinearLight&quot;, &quot;PinLight&quot;, &quot;SoftLight&quot; and &quot;SoftLightPS&quot; are non-commutative - swapping the order of the inputs results in a different blending function being used, i.e., the &quot;HardLight&quot; results are the same as &quot;Overlay&quot; commuted. For more details, see also:<rsl_link>http://www.pegtop.net/delphi/articles/blendmodes/index.htm</rsl_link>, <rsl_link>http://dunnbypaul.net/blends/</rsl_link>, <rsl_link>http://www.nathanm.com/photoshop-blending-math/</rsl_link>, or check the &quot;rsl_shrimp_layering.h&quot; header.</usage>
</shrimp>

<shrimp type="function" name="ColorAdd" description="Add color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_add( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_add( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Add&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorAverage" description="Average color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_avg( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_avg( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Average&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorBurn" description="Burn color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_burn( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_burn( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Burn&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorDarken" description="Darken color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_darken( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_darken( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Darken&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorDesaturate" description="Desaturate color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_desaturate( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_desaturate( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Desaturate&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorDifference" description="Difference color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_difference( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_difference( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Difference&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorDivide" description="Divide color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_divide( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_divide( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Divide&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorDodge" description="Dodge color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_dodge( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_dodge( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Dodge&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorExclusion" description="Exclusion color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_exclusion( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_exclusion( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Exclusion&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorHardlight" description="Hardlight color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_hardlight( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_hardlight( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Hardlight&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorIlluminate" description="Illuminate color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_illuminate( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_illuminate( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Illuminate&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorLighten" description="Lighten color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_lighten( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_lighten( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Lighten&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorLinearBurn" description="Linear Burn color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_linearburn( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_linearburn( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Linear Burn&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorLinearDodge" description="LinearDodge color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_lineardodge( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_lineardodge( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Linear Dodge&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorLinearlight" description="Linearlight color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_linearlight( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_linearlight( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Linear Light&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorMultiply" description="Multiply color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_multiply( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_multiply( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Multiply&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorOver" description="Over color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_over( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_over( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Over&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorOverlay" description="Overlay color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_overlay( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_overlay( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Overlay&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorPinlight" description="Pinlight color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_pinlight( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_pinlight( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Pin Light&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorReflect" description="Reflect color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_reflect( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_reflect( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Reflect&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorSaturate" description="Saturate color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_saturate( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_saturate( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Saturate&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorScreen" description="Screen color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_screen( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_screen( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Screen&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorSoftlight" description="Softlight color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_softlight( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_softlight( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Soft Light&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorSoftlightPS" description="SoftlightPS color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_softlightps( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_softlightps( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Soft Light PS&quot; blending mode (similar to Adobe Photoshop&apos;s &quot;softlight&quot; mode), using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorSubtract" description="Subtract color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_sub( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_sub( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Subtract&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="ColorVividlight" description="Vividlight color blending" author="rconstruct">
	<input name="BkgColor" description="1st color" type="color" default="color(1,0,0)" />
	<input name="FrgColor" description="2nd color" type="color" default="color(0,0,1)" />
	<input name="weight" description="Blending weight" type="float" default="0.5" />
	<input name="invert" description="Invert weight mask on/off" type="float" storage="uniform" default="0" />
	<output name="OutC" description="Blended color" type="color"/>
	<rsl_include>rsl_layering.h</rsl_include>
	<rsl_code>
	#define invertmask_$(invert)
	#ifdef invertmask_0
		$(OutC) = color_vividlight( $(BkgColor), $(FrgColor),
					clamp( $(weight), 0, 1) );
	#else
		$(OutC) = color_vividlight( $(BkgColor), $(FrgColor),
					1 - clamp( $(weight), 0, 1) );
	#endif // invertmask
	#undef invertmask_$(invert)
	</rsl_code>
	<usage>Blends background color &quot;BkgColor&quot; and foreground color &quot;FrgColor&quot; with the &quot;Vivid Light&quot; blending mode, using blending amount &quot;weight&quot;. The variable &quot;invert&quot; can only be 0 or 1 with no middle values, if it&quot;apos&quot;s set to 0, the weight mask is used as it is, if set to 1, it&quot;apos&quot;s inverted.</usage>
</shrimp>

<shrimp type="function" name="AmbientLight" description="Ambient light shader" author="rconstruct">
	<input name="intensity" description="Light intensity" type="float" default="1"/>
	<input name="lightcolor" description="Light color" type="color" default="color( 1, .93, .81 )"/>
	<input name="category" description="Light category" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="Cl" description="Light ray color" type="color"/>
	<rsl_code>
		__category = $(category);
		$(Cl) = $(intensity) * $(lightcolor);
		L = vector(0);
	</rsl_code>
	<usage>Ambient light shader.</usage>
</shrimp>

<shrimp type="function" name="DistantLight" description="Distant light shader" author="rconstruct">
	<input name="intensity" description="Light intensity" type="float" default="1"/>
	<input name="decay" description="Light decay" storage="uniform" type="float" default="0"/>
	<input name="lightcolor" description="Light color" type="color" default="color( 1, .93, .81 )"/>
	<input name="from" description="Light origin point" type="point" default="point &quot;shader&quot; (-15, 10, 5)"/>
	<input name="to" description="Light target point" type="point" default="point &quot;shader&quot; (0, 0, 0)"/>
	<input name="shadowmap" description="Shadow map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="samples" description="Shadow map samples" storage="uniform" type="float" default="4"/>
	<input name="width" description="Shadow map filter width" storage="uniform" type="float" default="1"/>
	<input name="blur" description="Shadow map blur" type="float" default="0"/>
	<input name="bias" description="Shadow map bias" storage="uniform" type="float" default="0.01"/>
	<input name="filter" description="Shadow map filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="nondiffuse" description="Non-diffuse light" storage="uniform" type="float" default="0" />
	<input name="nonspecular" description="Non-specular light" storage="uniform" type="float" default="0" />
	<input name="category" description="Light category" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="Cl" description="Light ray color" type="color"/>
	<rsl_include>rsl_shrimp_lights.h</rsl_include>
	<rsl_code>
		__nondiffuse = $(nondiffuse);
		__nonspecular = $(nonspecular);
		__category = $(category);
		/* tmp storage for shadow color */
		varying color $(blockname)_inshadow = color(0);
		
		$(Cl) = sdistantlight( $(from), $(to), $(shadowmap), $(filter),
						$(samples), $(width), $(bias), $(decay),
						$(intensity), $(blur), $(lightcolor),
						$(blockname)_inshadow );

		__shadow = $(blockname)_inshadow;
	</rsl_code>
	<usage>Distant light shader. Filter type defaults to &quot;gaussian&quot;, with &quot;box&quot; and &quot;triangle&quot; as optional. Bias defaults to global default, -1. The &quot;variable&quot; decay defaults to 0 - no decay, with 1 being linear decay, 2 being squared, 3 being cubic, and so on.</usage>
</shrimp>

<shrimp type="function" name="PointLight" description="Point light shader" author="rconstruct">
	<input name="intensity" description="Light intensity" type="float" default="400"/>
	<input name="lightcolor" description="Light color" type="color" default="color( 1, .93, .81 )"/>
	<input name="position" description="Light source position" type="point" default="point &quot;shader&quot; ( -15, 10, 5 )"/>
	<input name="decay" description="Light decay, see help" storage="uniform" type="float" default="2"/>
	<input name="shadowmap" description="Shadow map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="blur" description="Shadow map blur" type="float" default="0"/>
	<input name="width" description="Shadow map filter width" storage="uniform" type="float" default="1"/>
	<input name="samples" description="Shadow map samples" storage="uniform" type="float" default="1"/>
	<input name="bias" description="Shadow map bias" storage="uniform" type="float" default="0.01"/>
	<input name="filter" description="Shadow map filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="nondiffuse" description="Non-diffuse light" storage="uniform" type="float" default="0" />
	<input name="nonspecular" description="Non-specular light" storage="uniform" type="float" default="0" />
	<input name="category" description="Light category" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="Cl" description="Light ray color" type="color"/>
	<rsl_include>rsl_shrimp_lights.h</rsl_include>
	<rsl_code>
		/* standards declared at beginning of (preview) light shader */
		__nondiffuse = $(nondiffuse);
		__category = $(category);
		/* temp storage for shadow color */
		varying color $(blockname)_inshadow = color(0);
		
		__nonspecular = $(nonspecular);
		$(Cl) = spointlight( $(position), $(intensity), $(blur),
					$(width), $(samples), $(bias), $(decay), $(shadowmap),
					$(filter), $(lightcolor), $(blockname)_inshadow );

		__shadow = $(blockname)_inshadow;
	</rsl_code>
	<usage>Point light shader. The &quot;decay&quot; variable defaults to 0 - no decay, with 1 being linear decay, 2 being squared decay, 3 being cubic decay and so on.</usage>
</shrimp>

<shrimp type="function" name="SlideProjLight" description="Slide projector light shader" author="rconstruct">
	<input name="intensity" description="Light intensity" type="float" default="1"/>
	<input name="lightcolor" description="Light color" type="color" default="color (1, 1, 1)"/>
	<input name="decay" description="Light decay" storage="uniform" type="float" default="0"/>
	<input name="fov" description="Field of view" storage="uniform" type="float" default="45"/>
	<input name="from" description="Light source position" type="point" default="point &quot;shader&quot; ( -15, 10, 5 )"/>
	<input name="to" description="Light source target" type="point" default="point &quot;shader&quot; ( 0, 0, 0 )"/>
	<input name="up" description="Up position" type="point" default="point &quot;eye&quot; ( 0, 1, 0 )"/>
	<input name="slidemap" description="Slide map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="shadowmap" description="Shadow map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="shadowfilter" description="Shadow map filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="shadowblur" description="Shadow map blur" type="float" default="0"/>
	<input name="samples" description="Shadow map samples" storage="uniform" type="float" default="1"/>
	<input name="shadowwidth" description="Shadow map filter width" storage="uniform" type="float" default="1"/>
	<input name="shadowbias" description="Shadow map bias" storage="uniform" type="float" default="0.01"/>
	<input name="nondiffuse" description="Non-diffuse light" storage="uniform" type="float" default="0" />
	<input name="nonspecular" description="Non-specular light" storage="uniform" type="float" default="0" />
	<input name="category" description="Light category" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="Cl" description="Light ray color" type="color"/>
	<rsl_include>rsl_shrimp_lights.h</rsl_include>
	<rsl_code>
		__nondiffuse = $(nondiffuse);
		__nonspecular = $(nonspecular);
		__category = $(category);
		/* tmp storage for shadows */
		color $(blockname)_inshadow = color(0);

		$(Cl) = slideprojector( $(intensity), $(shadowblur), $(decay), $(fov),
								$(lightcolor), $(from), $(to), $(up),
								$(slidemap), $(shadowmap), $(shadowfilter),
								$(samples), $(shadowwidth), $(shadowbias),
								$(blockname)_inshadow );

		__shadow = $(blockname)_inshadow;
	</rsl_code>
	<usage>Slide projector light shader, from The RenderMan Repository, www.renderman.org . Requires a texture map (slide map) to work. Shadow bias defaults to global default, -1, while shadow filter type defaults to &quot;gaussian&quot;, with &quot;triangle&quot; and &quot;box&quot; as optional. The variable &quot;decay&quot; defaults to 0 (no decay), with 1 being linear decay, 2 being squared decay, 3 being cubic decay and so on.</usage>
</shrimp>

<shrimp type="function" name="ShadowSpotLight" description="Shadow Spotlight shader block" author="rconstruct">
	<input name="intensity" description="Light intensity" type="float" default="5000"/>
	<input name="lightcolor" description="Light color" type="color" default="color( 1, .93, .81 )"/>
	<input name="position" description="Light source position" type="point" default="point &quot;shader&quot; ( -15, 10, 5 )"/>
	<input name="target" description="Light source target position" type="point" default="point &quot;shader&quot; ( 0, 0, 0 )"/>
	<input name="coneangle" description="Cone angle" storage="uniform" type="float" default="30"/>
	<input name="conedelta" description="Cone delta angle" storage="uniform" type="float" default="5"/>
	<input name="beam" description="Beam distribution" storage="uniform" type="float" default="2"/>
	<input name="shadowmap" description="Shadow map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="filter" description="Filter type" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="samples" description="Shadow map samples" storage="uniform" type="float" default="16"/>
	<input name="blur" description="Shadow map blur" type="float" default="0"/>
	<input name="width" description="Shadow map filter width" storage="uniform" type="float" default="1"/>
	<input name="bias" description="Shadow map bias" storage="uniform" type="float" default="0.01"/>
	<input name="attenuation" description="Attenuation" type="float" default="1e6"/>
	<input name="nondiffuse" description="Non-diffuse light" storage="uniform" type="float" default="0" />
	<input name="nonspecular" description="Non-specular light" storage="uniform" type="float" default="0" />
	<input name="category" description="Light category" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="Cl" description="Light ray color" type="color"/>
	<rsl_include>rsl_shrimp_lights.h</rsl_include>
	<rsl_code>
		__nondiffuse = $(nondiffuse);
		__nonspecular = $(nonspecular);
		__category = $(category);
		/* tmp storage for shadows */
		color $(blockname)_inshadow = color(0);
		
		$(Cl) = sig2kshadowspot(	$(intensity), $(lightcolor), $(position),
									$(target), radians( $(coneangle) ),
									radians( $(conedelta)), $(beam), $(samples),
									$(bias), $(width), $(shadowmap), $(filter),
									$(blur), $(attenuation),
									$(blockname)_inshadow );

		__shadow = $(blockname)_inshadow;

	</rsl_code>
	<usage>Modified shadow spotlight shader, by Tal Lancaster, from The RenderMan repository ( www.renderman.org ). Modified to better handle atenuation. Bias overrides the global shadow bias value, with -1 being the global default, and blur, the amount to soften the shadow edges. Shadow map filter type defaults to &quot;gaussian&quot;, with &quot;triangle&quot; and &quot;box&quot; as optional.</usage>
</shrimp>

<shrimp type="function" name="Abs" description="Absolute value" author="rconstruct">
	<input name="x" description="Input value" type="float" default="1"/>
	<output name="value" description="Absolute value of x" type="float"/>
	<rsl_code>
		$(value) = abs( $(x) );
	</rsl_code>
	<usage>Returns the absolute value of the argument being passed.</usage>
</shrimp>

<shrimp type="function" name="Add" description="Addition block" author="rconstruct">
	<input name="A" description="1st input" type="normal color point vector float" type_parent="value" default="1"/>
	<input name="B" description="2nd or subsequent inputs" type="normal color point vector float" type_parent="value" multi="+" default="1"/>
	<output name="value" description="val = A + B" type="normal color point vector float"/>
	<rsl_code>
		$(value) = $(A) + $(B);
	</rsl_code>
	<usage>Adds 2 or more inputs. All the input pads will inherit the type of the output pad.</usage>
</shrimp>

<shrimp type="function" name="Divide" description="Division block" author="rconstruct">
	<input name="A" description="1st input" type="color point vector normal float" type_parent="value" default="1"/>
	<input name="B" description="2nd input" type="color point vector normal float" type_parent="value" default="1"/>
	<output name="value" description="val = A / B" type="color point vector normal float"/>
	<rsl_code>
		$(value) = $(A) / $(B);
	</rsl_code>
	<usage>Divides input A by input B.</usage>
</shrimp>

<shrimp type="function" name="FilteredAbs" description="Antialiased abs()" author="rconstruct">
	<input name="x" description="Value to test" type="float" default="1"/>
    <input name="filterwidth" description="Filter value" type="float" default="0.1"/>
	<output name="value" description="The smallest integer not smaller than a" type="float"/>
    <rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
        $(value) = filteredabs( $(x), $(filterwidth) );
	</rsl_code>
    <usage>Antialiased &quot;abs&quot;, by Larry Gritz (patterns.h). Returns the &quot;box&quot; filter of abs(t) from x-dx/2 to x+dx/2.</usage>
</shrimp>

<shrimp type="function" name="Mod" description="Return the positive remainder of a/b" author="rconstruct">
	<input name="A" description="Numerator" type="float" default="1"/>
	<input name="B" description="Denominator" type="float" default="1"/>
	<output name="value" description="The positive remainder of a/b" type="float"/>
	<rsl_code>
		$(value) = mod( $(A), $(B) );
	</rsl_code>
	<usage>Returns &quot;A&quot; modulus &quot;B&quot;.</usage>
</shrimp>

<shrimp type="function" name="Multiply" description="Multiplication block" author="rconstruct">
	<input name="A" description="1st input" type="color point vector normal float" type_parent="value" default="1"/>
	<input name="B" description="2nd or subsequent inputs" type="color point vector normal float" multi="*" type_parent="value" default="1"/>
	<output name="value" description="val = A * B" type="color point vector normal float"/>
	<rsl_code>
		$(value) = $(A) * $(B);
	</rsl_code>
	<usage>All inputs must be of the same type. The operation is done in parallel for each component.</usage>
</shrimp>

<shrimp type="function" name="Round" description="Return the integer closest to x" author="rconstruct">
	<input name="x" description="Input value" type="float" default="1"/>
	<output name="value" description="The integer closest to x" type="float"/>
	<rsl_code>
		$(value) = round( $(x) );
	</rsl_code>
	<usage>Returns the closest integer to the supplied parameter &quot;x&quot;.</usage>
</shrimp>

<shrimp type="function" name="Subtract" description="Subtraction block" author="rconstruct">
	<input name="A" description="1st input" type="float color point vector normal float" type_parent="value" default="1"/>
	<input name="B" description="2nd input" type="float color point vector normal float" type_parent="value" default="1"/>
	<output name="value" description="val = A - B" type="float color point vector normal float"/>
	<rsl_code>
		$(value) = $(A) - $(B);
	</rsl_code>
	<usage>Note that unlike the operators in the Renderman shading language the result is always the same type as the inputs. Also both inputs must be of the same type. The operation is done in parallel for each component.</usage>
</shrimp>

<shrimp type="function" name="AND" description="Boolean AND function" author="rconstruct">
	<input name = "A" description="1st value" type="float" default="1"/>
	<input name = "B" description="2nd value" type="float" default="1"/>
	<output name="value" description="The intersection of A and B" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = intersection( $(A), $(B) );
	</rsl_code>
	<usage>This block computes the logical AND of the two inputs.</usage>
</shrimp>

<shrimp type="function" name="NOT" description="Boolean NOT function" author="rconstruct">
	<input name = "A" description="Input value" type="float" default="1"/>
	<output name="value" description="The logical inversion of A" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = complement( $(A) );
	</rsl_code>
	<usage>This block computes the logical inversion of the input.</usage>
</shrimp>

<shrimp type="function" name="OR" description="Boolean OR function" author="rconstruct">
	<input name = "A" description="1st value" type="float" default="1"/>
	<input name = "B" description="2nd value" type="float" default="1"/>
	<output name="value" description="The union of A and B" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = union( $(A), $(B) );
	</rsl_code>
	<usage>This block computes the logical OR of the two inputs.</usage>
</shrimp>

<shrimp type="function" name="SUB" description="Boolean difference" author="rconstruct">
	<input name = "A" description="1st value" type="float" default="1"/>
	<input name = "B" description="2nd value" type="float" default="1"/>
	<output name="value" description="Performs the logical operation A-B" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = difference( $(A), $(B) );
	</rsl_code>
	<usage>This block computes the logical operation A-B.</usage>
</shrimp>

<shrimp type="function" name="XOR" description="Boolean exclusive or" author="rconstruct">
	<input name = "A" description="1st value" type="float" default="1"/>
	<input name = "B" description="2nd value" type="float" default="1"/>
	<output name="value" description="Performs the logical operation A XOR B" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = exclusiveor( $(A), $(B) );
	</rsl_code>
	<usage>This block computes the logical operation A XOR B.</usage>
</shrimp>

<shrimp type="function" name="CxAbs" description="Complex Absolute Value block" author="rconstruct">
	<input name="A" description="1st input" type="vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_abs( $(A) );
	</rsl_code>
	<usage>Complex absolute value, for a complex number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxAdd" description="Complex Addition block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float vector" default="vector(0,0,0)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_add( $(A), $(B) );
	</rsl_code>
	<usage>Complex addition, adds two complex numbers, a complex and a real, or a real and a complex. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxCos" description="Complex Cosine block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_cos( $(A) );
	</rsl_code>
	<usage>Complex cosine, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxCosh" description="Complex Hyperbolic Cosine block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_cosh( $(A) );
	</rsl_code>
	<usage>Complex hyperbolic cosine, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxDiv" description="Complex Division block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float vector" default="vector(0,0,0)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_div( $(A), $(B) );
	</rsl_code>
	<usage>Complex division, for two complex numbers, a complex and a real, or a real and a complex. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxExp" description="Complex Exponential block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_exp( $(A) );
	</rsl_code>
	<usage>Complex exponential, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxIm" description="Get Imarinary Part block" author="rconstruct">
	<input name="A" description="1st input" type="vector" default="vector(1,1,1)"/>
	<output name="value" description="Imaginary component" type="float"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_im( $(A) );
	</rsl_code>
	<usage>Get the imaginary part of a complex number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxInv" description="Complex Inverse block" author="rconstruct">
	<input name="A" description="1st input" type="vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_inv( $(A) );
	</rsl_code>
	<usage>Complex inversion, for a complex number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxLog" description="Complex Logarithm block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_log( $(A) );
	</rsl_code>
	<usage>Natural logarithm. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxMod" description="Complex Modulus block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_mod( $(A) );
	</rsl_code>
	<usage>Complex modulus block, the distance from the origin in polar coordinates, aka complex modulus, or norm or length, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxMul" description="Complex Multiplication block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float vector" default="vector(0,0,0)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_mul( $(A), $(B) );
	</rsl_code>
	<usage>Complex multiplication, for two complex numbers, a complex and a real, or a real and a complex. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxNeg" description="Complex Negation block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_neg( $(A) );
	</rsl_code>
	<usage>Complex negation, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxPow" description="Complex Power block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float vector" default="vector(0,0,0)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_pow( $(A), $(B) );
	</rsl_code>
	<usage>Complex power block, raises complex to complex or real power, or real to complex power. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxRe" description="Get Real Part block" author="rconstruct">
	<input name="A" description="1st input" type="vector" default="vector(1,1,1)"/>
	<output name="value" description="Real component" type="float"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_re( $(A) );
	</rsl_code>
	<usage>Get the real part of a complex number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxNRoot" description="Complex Nth Root block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float" default="1"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_root( $(A), $(B) );
	</rsl_code>
	<usage>Complex Nth root, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxSet" description="Create Complex number block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float" default="0"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(A:type)
	#ifdef $(blockname)_vector
		$(value) = vector( xcomp( $(A) ), ycomp( $(A) ), 0 );
	#else
		$(value) = vector( $(A), $(B), 0);
	#endif
	#undef $(blockname)_$(A:type)
	</rsl_code>
	<usage>Create a complex number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxSin" description="Complex Sine block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_sin( $(A) );
	</rsl_code>
	<usage>Complex sine, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxSinh" description="Complex Hyperbolic Sine block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_sinh( $(A) );
	</rsl_code>
	<usage>Complex hyperbolic sine, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxSqrt" description="Complex Square Root block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_sqrt( $(A) );
	</rsl_code>
	<usage>Complex square root, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxSub" description="Complex Subtraction block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<input name="B" description="2nd input" type="float vector" default="vector(0,0,0)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_sub( $(A), $(B) );
	</rsl_code>
	<usage>Complex subtraction, subtracts two complex numbers, a complex and a real, or a real and a complex. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="CxTan" description="Complex Tangent block" author="rconstruct">
	<input name="A" description="1st input" type="float vector" default="vector(1,1,1)"/>
	<output name="value" description="Complex result" type="vector"/>
	<rsl_include>rsl_odwikicomplex.h</rsl_include>
	<rsl_code>
		$(value) = cx_tan( $(A) );
	</rsl_code>
	<usage>Complex tangent, for a complex or a real number. Based on Odforce&apos;s odwiki complex.h.</usage>
</shrimp>

<shrimp type="function" name="Deriv" description="Compute Derivative" author="rconstruct">
	<input name="num" description="Value to compute derivative at" type_parent="value" type="color vector point float" default="0"/>
	<input name="den" description="Value to compute derivative with respect to" type="float" default="1"/>
	<output name="value" description="Derivative of num with respect to den" type="color vector point float"/>
	<rsl_code>
		$(value) = Deriv( $(num), $(den) );
	</rsl_code>
	<usage>Returns the derivative of the first argument with respect to a unit change in the second argument.</usage>
</shrimp>

<shrimp type="function" name="Du" description="Change of surface parameters" author="rconstruct">
    <input name="P" description="Change of surface parameter" type_parent="value" type="float color vector point" default="P"/>
    <output name="value" description="Change of surface parameter" type="float color vector point"/>
    <rsl_code>
	    $(value) = Du( $(P) );
    </rsl_code>
	<usage>Returns the derivative of arbitrary expression &quot;p&quot; with respect to surface parameter &quot;u&quot;.</usage>
</shrimp>

<shrimp type="function" name="Dv" description="Change of surface parameters" author="rconstruct">
    <input name="P" description="Change of surface parameter" type_parent="value" type="float color vector point" default="P"/>
    <output name="value" description="Change of surface parameter" type="float color vector point"/>
    <rsl_code>
	    $(value) = Dv( $(P) );
    </rsl_code>
	<usage>Returns the derivative of arbitrary expression &quot;p&quot; with respect to surface parameter &quot;v&quot;.</usage>
</shrimp>

<shrimp type="function" name="Exp" description="Raise e to the power x" author="rconstruct">
	<input name="power" description="Power" type="float" default="1"/>
	<output name="value" description="val = e to the power x" type="float"/>
	<rsl_code>
		$(value) = exp( $(power) );
	</rsl_code>
	<usage>Return e to the power of x.</usage>
</shrimp>

<shrimp type="function" name="InvSqrt" description="Inverse square root" author="rconstruct">
	<input name="x" description="Input value" type="float" default="1"/>
	<output name="value" description="val = the inverse sqare root of x" type="float"/>
	<rsl_code>
		$(value) = inversesqrt( $(x) );
	</rsl_code>
	<usage>Returns 1/sqrt(x).</usage>
</shrimp>

<shrimp type="function" name="Log" description="Logarithm" author="rconstruct">
	<input name="x" description="Input value" type="float" default="1"/>
	<input name="base" description="Base of log" type="float" default="UND"/>
	<output name="value" description="val = log(x) with base base" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	#define base_$(base)
	#ifdef base_UND
		$(value) = log( $(x) );
	#else
		$(value) = log( $(x), $(base) );
	#endif
	#undef base_$(base)
	</rsl_code>
<usage>Returns the natural logarithm of &quot;x&quot; in its single argument form. If the &quot;base&quot; is specified (default is &quot;UNDefined&quot;), then it returns the logarithm of &quot;x&quot; in &quot;base&quot;.</usage>
</shrimp>

<shrimp type="function" name="Power" description="Power block" author="rconstruct">
	<input name="base" description="Input value" type="float" default="1"/>
	<input name="exponent" description="exponent" type="float" default="1"/>
	<output name="power" description="val = A raised to the power x" type="float"/>
	<rsl_code>
		$(power) = pow( $(base), $(exponent) );
	</rsl_code>
	<usage>Returns &quot;base&quot; raised to &quot;exponent&quot;.</usage>
</shrimp>

<shrimp type="function" name="Sqrt" description="Square root" author="rconstruct">
	<input name="x" description="Input value" type="float" default="1"/>
	<output name="value" description="val = sqrt(x)" type="float"/>
	<rsl_code>
		$(value) = sqrt( $(x) );
	</rsl_code>
	<usage>Returns the square root of the argument</usage>
</shrimp>

<shrimp type="function" name="Ceil" description="Return the smallest integer not smaller than x" author="rconstruct">
	<input name="x" description="Input value" type="float" default="0"/>
	<output name="value" description="The smallest integer not smaller than x" type="float"/>
	<rsl_code>
		$(value) = ceil( $(x) );
	</rsl_code>
	<usage>Returns the smallest integer not smaller than x.</usage>
</shrimp>

<shrimp type="function" name="Clamp" description="Clamp the input between to values" author="rconstruct">
	<input name="x" description="Input value" type_parent="value" type="point vector normal color float" default="1"/>
	<input name="minimum" description="minimum value" type_parent="value" type="point vector normal color float" default="0.0"/>
	<input name="maximum" description="maximum value" type_parent="value" type="point vector normal color float" default="1.0"/>
	<output name="value" description="Clamp a between min and max" type="point vector normal color float"/>
	<rsl_code>
		$(value) = clamp( $(x), $(minimum), $(maximum) );
	</rsl_code>
	<usage>Clamps the first argument between the minimum and maximum values provided.</usage>
</shrimp>

<shrimp type="function" name="Erf" description="Error function" author="rconstruct">
	<input name="x" description="Input" type="float" default="0"/>
	<output name="value" description="Output" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = mm_erf( $(x) );
	</rsl_code>
<usage>Based on Mario Marengo&apos;s implementation of the error function (also known as integrated Gauss function or integrated distribution).</usage>
</shrimp>

<shrimp type="function" name="Erfc" description="Complementary error function" author="rconstruct">
	<input name="x" description="Input" type="float" default="0"/>
	<output name="value" description="Output" type="float"/>
	<rsl_include>rsl_shrimp_helpers.h</rsl_include>
	<rsl_code>
		$(value) = mm_erfc( $(x) );
	</rsl_code>
<usage>Complementary error function, based on Mario Marengo&apos;s implementation of the error function.</usage>
</shrimp>

<shrimp type="function" name="FSmoothStep" description="Filtered smoothstep function" author="rconstruct">
	<input name="x" description="Value to test" type="float" default="1"/>
	<input name="minimum" description="Position of bottom of step" type="float" default="0"/>
	<input name="maximum" description="position of top of step" type="float" default="1"/>
	<input name="filterwidth" description="Filter value" type="float" default="1"/>
	<output name="value" description="value of smoothstep function at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = filteredsmoothstep( $(minimum), $(maximum), $(x), $(filterwidth) );
	</rsl_code>
	<usage>Antialiased smoothstep by Larry Gritz. Returns the &quot;box&quot; filter of smoothstep(e0, e1, t) from x-dx/2 to x+dx/2.</usage>
</shrimp>

<shrimp type="function" name="Filterstep" description="Filterstep function" author="rconstruct">
	<input name="x" description="value to test" type="float" default="s"/>
	<input name="minimum" description="position of step" type="float" default="0"/>
    <input name="maximum" description="optional 2nd value for range filtering" type="float" default="UND"/>
    <input name="width" description="filter width" type="float" default="0.1"/>
    <input name="filter" description="filter type" storage="uniform" type="string" default="&quot;catmull-rom&quot;"/>
	<output name="value" description="value of step function at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(maximum)
	#ifdef $(blockname)_UND
		$(value) = filterstep( $(x), $(minimum), "width", $(width),
										"filter", $(filter));
	#else
		$(value) = filterstep( $(x), $(minimum), $(maximum), "width", $(width),
											"filter", $(filter) );
	#endif
	#undef $(blockname)_$(maximum)
	</rsl_code>
	<usage>An antialiased &quot;step&quot; function. It&apos;s similar to &quot;step&quot;, but the result is filtered. If the optional max value is given, the result is filtered in the range between min and max. By default, max is unset (via &quot;UND&quot;(efined) symbol). The filter types are: &quot;box&quot;, &quot;triangle&quot;, &quot;catmull-rom&quot;, and &quot;gaussian&quot;. Pixie adds to these filters, the following: &quot;sinc&quot;, &quot;blackman-harris&quot;, &quot;mitchell&quot;.</usage>
</shrimp>

<shrimp type="function" name="Floor" description="Return the largest integer not greater than x" author="rconstruct">
	<input name="x" description="Input value" type="float" default="0"/>
	<output name="value" description="The largest integer not greater than x" type="float"/>
	<rsl_code>
		$(value) = floor( $(x) );
	</rsl_code>
	<usage>Returns the largest integer not greater than x.</usage>
</shrimp>

<shrimp type="function" name="Max" description="Return the largest input" author="rconstruct">
	<input name="A" description="1st input" type_parent="value" type="color point vector normal float" default="0"/>
	<input name="B" description="2nd or subsequent inputs" type_parent="value" type="color point vector normal float" multi="," default="1"/>
	<output name="value" description="out = the largest input" type="color point vector normal float"/>
	<rsl_code>
		$(value) = max( $(A), $(B) );
	</rsl_code>
	<usage>Returns the maximum of the arguments given. When evaluating point type variables, the arguments will be evaluated on a component basis.</usage>
</shrimp>

<shrimp type="function" name="Min" description="Return the smallest input" author="rconstruct">
	<input name="A" description="1st input" type_parent="value" type="color point vector normal float" default="0"/>
	<input name="B" description="2nd or subsequent inputs" type_parent="value" type="color point vector normal float" multi="," default="0"/>
	<output name="value" description="out = the smallest input" type="color point vector normal float"/>
	<rsl_code>
		$(value) = min( $(A), $(B) );
	</rsl_code>
	<usage>Returns the minimum of the arguments given. When evaluating point type variables, the arguments will be evaluated on a component basis.</usage>
</shrimp>

<shrimp type="function" name="Random" description="A Random value" author="rconstruct">
	<input name="minimum" description="minimum value" type_parent="value" type="color point float" default="0"/>
	<input name="maximum" description="maximum value" type_parent="value" type="color point float" default="1"/>
	<output name="value" description="A random value between min and max" type="color point float"/>
	<rsl_code>
		$(value) = ( $(maximum) - $(minimum) )*( $(value:type) random())
					+ $(minimum);
	</rsl_code>
	<usage>Returns a random number between &quot;minimum&quot; and &quot;maximum&quot;, with types allowed defaulting to point, color and float, altough these vary with each renderer&apos;s implementation.</usage>
</shrimp>

<shrimp type="function" name="SmoothStep" description="Smooth step function" author="rconstruct">
	<input name="x" description="value to test" type_parent="value" type="color float" default="0"/>
	<input name="minimum" description="position of bottom of step" type_parent="value" type="color float" default="0"/>
	<input name="maximum" description="position of top of step" type_parent="value" type="color float" default="1"/>
	<output name="value" description="value of smoothstep function at x" type="color float"/>
	<rsl_code>
	#define stype_$(minimum:type) 1
	#if RENDERER == prman
		$(value) = smoothstep( $(minimum), $(maximum), $(x) );
	#else
		#ifdef stype_float
			$(value) = smoothstep( $(minimum), $(maximum), $(x) );
		#else
			$(value) = color(
			smoothstep(comp( $(minimum),0),comp( $(maximum),0),comp( $(x), 0)),
			smoothstep(comp( $(minimum),1),comp( $(maximum),1),comp( $(x), 1)),
			smoothstep(comp( $(minimum),2),comp( $(maximum),2),comp( $(x), 2)));
		#endif /* stype_$(minimum:type) */
	#endif /* RENDERER */
	#undef stype_$(minimum:type)
		
	</rsl_code>
	<usage>Result is zero if &quot;x&quot; is less than &quot;minimum&quot;, one if &quot;x&quot; is greater than &quot;maximum&quot;, otherwise it is interpolated between zero and one with a smooth Hermite curve. If the type is color, then it operates on a component basis.</usage>
</shrimp>

<shrimp type="function" name="Spline" description="Fits a Spline to the given control points" author="rconstruct">
	<input name="basis" description="The basis function" storage="uniform" type="string" default="&quot;catmull-rom&quot;"/>
	<input name="x" description="The value to test the spline at" type="float" default="0"/>
	<input name="point1" description="The 1st Control Point" type_parent="value" type="point vector color float" default="0"/>
	<input name="point2" description="The 2nd Control Point" type_parent="value" type="point vector color float" default="0.2"/>
	<input name="point3" description="The 3rd Control Point" type_parent="value" type="point vector color float" default="0.8"/>
	<input name="point4" description="The 4th or subsequent Control Points" type_parent="value" type="point vector color float" multi="," default="1"/>
	<output name="value" description="The value of the spline at x" type="point vector color float"/>
	<rsl_code>
		$(value) = spline(	$(basis), $(x), $(point1), $(point2),
							$(point3), $(point4) );
	</rsl_code>
<usage>Fits a spline into the control points passed, using the specified spline basis function. These can be of type &quot;catmull-rom&quot;, &quot;bezier&quot;, &quot;bspline&quot;, &quot;hermite&quot;, or &quot;linear&quot;. Defaults to &quot;catmull-rom&quot;. In 3delight, any spline type may be prefixed by &quot;solve&quot;, such as &quot;solvecatmull-rom&quot;, in which case this shadeop becomes a root solver and may be used as an invert function. The number of required data points is, for &quot;catmull-rom&quot;, 4 or higher; for &quot;bezier&quot;, 4n+3; for &quot;hermite&quot;, 4n+2; for &quot;bspline&quot; 4 or higher.</usage>
</shrimp>

<shrimp type="function" name="Step" description="Step function" author="rconstruct">
	<input name="x" description="value to test" type_parent="value" type="color float" default="1"/>
	<input name="minimum" description="position of step" type_parent="value" type="color float" default="1"/>
	<output name="value" description="value of step function at x" type="color float"/>
	<rsl_code>
	#define stype_$(minimum:type)
	#if RENDERER == prman
		$(value) = step( $(minimum), $(x) );
	#else
		#ifdef stype_float
			$(value) = step( $(minimum), $(x) );
		#else
			$(value) = color(	step( comp( $(minimum),0), comp( $(x),0) ),
								step( comp( $(minimum),1), comp( $(x),1) ),
								step( comp( $(minimum),2), comp( $(x),2) ));
		#endif /* stype_$(minimum:type) */
	#endif /* RENDERER */
	#undef stype_$(minimum:type)
	</rsl_code>
	<usage>Returns 0 if &quot;x&quot; is less than &quot;minimum&quot;, otherwise returns 1. On color types, it operates on a component basis. </usage>
</shrimp>

<shrimp type="function" name="Equal" description="Equal to" author="rconstruct">
	<input name="A" description="Input value" type="float" default="0"/>
	<input name="B" description="Input value" type="float" default="0"/>
	<output name="value" description="1 if a==b, 0 if not" type="float"/>
	<rsl_code>
	if( $(A) == $(B) )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if A is equal to B, else returns 0.</usage>
</shrimp>

<shrimp type="function" name="Even" description="Returns 1 if the input is even, otherwise 0" author="rconstruct">
	<input name = "A" description="Input value" type="float" default="0"/>
	<output name="value" description="Returns 1 if A is even" type="float"/>
	<rsl_code>
	if( mod( $(A), 2) == 0 )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if the input is even, otherwise returns 0.</usage>
</shrimp>

<shrimp type="function" name="Greater" description="Greater than" author="rconstruct">
	<input name="A" description="Input value" type="float" default="0"/>
	<input name="B" description="Input value" type="float" default="0"/>
	<output name="value" description="1 if a&gt;b, 0 if not" type="float"/>
	<rsl_code>
	if( $(B) > $(B) )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if A is greater than B, else returns 0.</usage>
</shrimp>

<shrimp type="function" name="GrtEqual" description="Greater than or equal to" author="rconstruct">
	<input name="A" description="Input value" type="float" default="0"/>
	<input name="B" description="Input value" type="float" default="0"/>
	<output name="value" description="1 if a&gt;=b, 0 if not" type="float"/>
	<rsl_code>
	if( $(A) >= $(B) )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if A is greater than or equal to B, else returns 0.</usage>
</shrimp>

<shrimp type="function" name="If" description="Conditionaly pass a value" author="rconstruct">
	<input name="x" description="Condition value, true if non-zero, false if zero" type="float" default="0"/>
	<input name="true_value" description="Input value to pass through if x is true" type_parent="value" type="string vector point normal color float" default="0"/>
	<input name="false_value" description="Input value to pass through if exp is false" type_parent="value" type="string vector point normal color float" default="0"/>
	<output name="value" description="if condition is true then this is true_value, otherwise it is false_value" type="string vector point normal color float"/>
	<rsl_code>
	if( $(x) )
		$(value) = $(true_value);
	else
		$(value) = $(false_value);
	</rsl_code>
	<usage>The value of &quot;x&quot; is a float that determines which input value is passed to the output. Any non-zero value is regarded as true.</usage>
</shrimp>

<shrimp type="function" name="Lower" description="Lower than" author="rconstruct">
	<input name="a" description="Input value" type="float" default="0"/>
	<input name="b" description="Input value" type="float" default="0"/>
	<output name="value" description="1 if a&lt;b, 0 if not" type="float"/>
	<rsl_code>
	if( $(b) > $(a) )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if A is lower than B, else returns 0.</usage>
</shrimp>

<shrimp type="function" name="LowerEqual" description="Lower than or equal to" author="rconstruct">
	<input name="A" description="Input value" type="float" default="0"/>
	<input name="B" description="Input value" type="float" default="0"/>
	<output name="value" description="1 if a&lt;=b, 0 if not" type="float"/>
	<rsl_code>
	if( $(B) >= $(A) )
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if A is lower than or equal to B, else returns 0.</usage>
</shrimp>

<shrimp type="function" name="Odd" description="Returns 1 if the input is odd, otherwise 0" author="rconstruct">
	<input name = "A" description="Input value" type="float" default="0"/>
	<output name="value" description="Returns 1 if A is odd" type="float"/>
	<rsl_code>
	if( mod( $(A), 2 ) == 1)
		$(value) = 1;
	else
		$(value) = 0;
	</rsl_code>
	<usage>Returns 1 if the input is odd, otherwise returns 0.</usage>
</shrimp>

<shrimp type="function" name="Sign" description="Test the sign of a" author="rconstruct">
	<input name="A" description="Input value" type="float" default="0"/>
	<output name="value" description="-1 if a&lt;0, 0 if a=0, 1 if a&gt;0" type="float"/>
	<rsl_code>
	$(value) = sign( $(A) );
	</rsl_code>
	<usage>Returns 1 if the value being tested is positive or zero, otherwise returns -1.</usage>
</shrimp>

<shrimp type="function" name="acos" description="Arc cosine block" author="rconstruct">
	<input name="A" description="Input value" type="float" default="1"/>
	<output name="value" description="val = acos( a )" type="float"/>
	<rsl_code>
		$(value) = acos( $(A) );
	</rsl_code>
	<usage>Returns the arc cosine in the [0,PI] range.</usage>
</shrimp>

<shrimp type="function" name="asin" description="Arc sine block" author="rconstruct">
	<input name="A" description="Input value" type="float" default="1"/>
	<output name="value" description="Arc sine value" type="float"/>
	<rsl_code>
		$(value) = asin( $(A) );
	</rsl_code>
	<usage>Returns the arc sine in the [-PI/2,PI/2] range.</usage>
</shrimp>

<shrimp type="function" name="atan" description="Arc tangent block" author="rconstruct">
	<input name="A" description="Input value" type="float" default="1"/>
	<input name="B" description="Input value" type="float" default="UND"/>
	<output name="value" description="Arc tangent value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	#define tanxy_$(B) 1
	#ifdef tanxy_UND
		$(value) = atan( $(A) );
	#else
		$(value) = atan( $(A), $(B) );
	#endif /* tanxy_$(B) */
	#undef tanxy_$(B)
	</rsl_code>
	<usage>Returns the arc tangent in the [-PI/2,PI/2] range with one argument. With two arguments, returns the arc tangent of y/x in the [-PI,PI] range. The second argument defaults to &quot;UND&quot;(efined), so the single argument form is used by default.</usage>
</shrimp>

<shrimp type="function" name="Cos" description="Cosine block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Cosine value" type="float"/>
	<rsl_code>
		$(value) = cos( $(theta) );
	</rsl_code>
	<usage>Standard trigonomic cosine function of radian arguments.</usage>
</shrimp>

<shrimp type="function" name="Cosh" description="Hyperbolic cosine block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Output value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = cosh( $(theta) );
	</rsl_code>
	<usage>Hyperbolic cosine function.</usage>
</shrimp>

<shrimp type="function" name="Cross" description="Compute cross product" author="rconstruct">
	<input name = "A" description="1st Input" type_parent="value" type="normal point vector" default="vector(0)"/>
	<input name = "B" description="2nd Input" type_parent="value" type="normal point vector" default="vector(1)"/>
	<output name="value" description="val = A ^ B" type="normal point vector"/>
	<rsl_code>
		$(value) = $(A)^$(B);
	</rsl_code>
	<usage>Returns a vector which is perpendicular to both the input vectors.</usage>
</shrimp>

<shrimp type="function" name="Degrees" description="Convert radians to degrees" author="rconstruct">
	<input name="radians" description="Input angle in radians" type="float" default="1"/>
	<output name="degrees" description="Angle converted to degrees" type="float"/>
	<rsl_code>
		$(deg) = degrees( $(rad) );
	</rsl_code>
	<usage>Converts input value from radians to degrees.</usage>
</shrimp>

<shrimp type="function" name="Dot" description="Compute dot product" author="rconstruct">
	<input name = "A" description="1st Input" type="normal point vector" default="vector(0)"/>
	<input name = "B" description="2nd Input" type="normal point vector" default="vector(1)"/>
	<output name="value" description="val = A . B" type="float"/>
	<rsl_code>
		$(value) = $(A).$(B);
	</rsl_code>
	<usage>Returns the dot product of two vectors, the sum of the products of each component of the two vectors.</usage>
</shrimp>

<shrimp type="function" name="Radians" description="Convert degrees to radians" author="rconstruct">
	<input name="degrees" description="Input angle in degrees" type="float" default="1"/>
	<output name="radians" description="Angle converted to radians" type="float"/>
	<rsl_code>
		$(rad) = radians( $(deg) );
	</rsl_code>
	<usage>Converts the input value from degrees to radians.</usage>
</shrimp>

<shrimp type="function" name="Sin" description="Sine block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Sine of value" type="float"/>
	<rsl_code>
		$(value) = sin( $(theta) );
	</rsl_code>
	<usage>Standard trigonomic sine function of radian arguments.</usage>
</shrimp>

<shrimp type="function" name="Sinh" description="Hyperbolic sine block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Output value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = sinh( $(theta) );
	</rsl_code>
	<usage>Hyperbolic sine function.</usage>
</shrimp>

<shrimp type="function" name="Tan" description="Tangent block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Tangent value." type="float"/>
	<rsl_code>
		$(value) = tan( $(theta) );
	</rsl_code>
	<usage>Standard trigonomic tangent function.</usage>
</shrimp>

<shrimp type="function" name="Tanh" description="Hyperbolic tangent block" author="rconstruct">
	<input name="theta" description="Input value in radians" type="float" default="1"/>
	<output name="value" description="Output value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = tanh( $(theta) );
	</rsl_code>
	<usage>Hyperbolic tangent function.</usage>
</shrimp>

<shrimp type="function" name="UConst" description="Useful constants" author="rconstruct">
	<output name="PI" description="PI value" type="float"/>
	<output name="PIover2" description="PI/2 value" type="float"/>
	<output name="2PI" description="2PI value" type="float"/>
	<output name="1overPI" description="1/PI value" type="float"/>
	<output name="E" description="Euler&apos;s number" type="float"/>
	<output name="Phi" description="The golden ratio" type="float"/>
	<output name="Sin36" description="sin(radians(36))" type="float"/>
	<output name="Sin72" description="sin(radians(72))" type="float"/>
	<output name="Cos36" description="cos(radians(36))" type="float"/>
	<output name="Cos72" description="cos(radians(72))" type="float"/>
	<output name="Sqrt2" description="sqrt(2)" type="float"/>
	<output name="Sqrt3" description="sqrt(3)" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(Pi) = S_PI;
		$(Piover2) = S_PI_2;
		$(2Pi) = S_2PI;
		$(1overPi) = S_1_PI;
		$(E) = S_E;
		$(Phi) = S_PHI;
		$(Sin36) = S_SIN36;
		$(Sin72) = S_SIN72;
		$(Cos36) = S_COS36;
		$(Cos72) = S_COS72;
		$(Sqrt2) = S_SQRT2;
		$(Sqrt3) = S_SQRT3;
	</rsl_code>
	<usage>Useful constants: Euler&apos;s number, PI, PI/2, 2PI, 1/PI, the Golden ratio, sin and cosines of 32 and 72 degrees, and the square root of 2 and 3.</usage>
</shrimp>


<shrimp type="function" name="Arraylength" description="Returns the number of elements in array" author="rconstruct">
    <input name="array" description="Array element" type="point color normal vector float" default="0"/>
    <output name="value" description="Number of elements" type="float"/>
	<rsl_code>
	    $(value) = arraylength( $(array) );
	</rsl_code>
	<usage>Returns the number of elements in the supplied array &quot;array&quot;, or -1 if &quot;var&quot; is an scalar. Notice that RSL allows for single dimensional arrays of any basic data type.</usage>
</shrimp>

<shrimp type="function" name="Determinant" description="Gets the determinant of matrix M" author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="0"/>
    <output name="determinant" description="Matrix determinant" type="float"/>
	<rsl_code>
	    $(determinant) = determinant( $(matrix) );
	</rsl_code>
	<usage>Gets the determinant of matrix M.</usage>
</shrimp>

<shrimp type="function" name="MatrixGetComp" description="Get a component of a matrix" author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="0"/>
    <input name="row" description="Input row" type="float" default="1"/>
    <input name="column" description="Input column" type="float" default="1"/>
    <output name="component" description="Matrix component" type="float"/>
	<rsl_code>
	    $(component) = comp( $(matrix), $(row), $(column) );
	</rsl_code>
	<usage>Gets the row and column component of matrix M.</usage>
</shrimp>

<shrimp type="function" name="Minverse" description="Invert matrix M." author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="1"/>
    <output name="inverse" description="Inverted matrix" type="matrix"/>
	<rsl_code>
	#if RENDERER == _3delight
		$(inverse) = inverse( $(matrix) );
	#else
		$(inverse) = 1 / $(matrix) ;
	#endif /* RENDERER */
	</rsl_code>
	<usage>Inverts the input matrix.</usage>
</shrimp>

<shrimp type="function" name="Mrotate" description="Rotates matrix M" author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="1"/>
	<input name="axis" description="Vector axis" type="vector" default="vector(1)"/>
	<input name="angle" description="Angle" type="float" default="1"/>
    <output name="newmatrix" description="Rotated matrix" type="matrix"/>
	<rsl_code>
		$(newmatrix) = rotate( $(matrix), $(angle), $(axis) );
	</rsl_code>
	<usage>Rotates a matrix M, on axis V, for X angle. These functions are similar to the RI statements &quot;RiTranslate&quot;, &quot;RiRotate&quot; and &quot;RiScale&quot;, except that the rotation angle in &quot;rotate&quot; is in radians, not in degrees, as with &quot;RiRotate&quot;.</usage>
</shrimp>

<shrimp type="function" name="Mscale" description="Scales matrix M" author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="1"/>
	<input name="P" description="Point input" type="point" default="P"/>
    <output name="newmatrix" description="Translated matrix" type="matrix"/>
	<rsl_code>
		$(newmatrix) = scale( $(matrix), $(P) );
	</rsl_code>
	<usage>Scales a matrix M. These functions are similar to the RI statements &quot;RiTranslate&quot;, &quot;RiRotate&quot;, and &quot;RiScale&quot;, except that the rotation angle in &quot;rotate&quot; is in radians, not in degrees as with &quot;RiRotate&quot;.</usage>
</shrimp>

<shrimp type="function" name="MatrixSetcomp" description="Set the components of a matrix M" author="rconstruct">
	<input name="row1col1" description="row 1, component 1" type="float" default="0"/>
	<input name="row1col2" description="row 1, component 2" type="float" default="0"/>
	<input name="row1col3" description="row 1, component 3" type="float" default="0"/>
    <input name="row1col4" description="row 1, component 4" type="float" default="0"/>
	<input name="row2col1" description="row 2, component 1" type="float" default="0"/>
	<input name="row2col2" description="row 2, component 2" type="float" default="0"/>
	<input name="row2col3" description="row 2, component 3" type="float" default="0"/>
    <input name="row2col4" description="row 2, component 4" type="float" default="0"/>
	<input name="row3col1" description="row 3, component 1" type="float" default="0"/>
	<input name="row3col2" description="row 3, component 2" type="float" default="0"/>
	<input name="row3col3" description="row 3, component 3" type="float" default="0"/>
    <input name="row3col4" description="row 3, component 4" type="float" default="0"/>
	<input name="row4col1" description="row 4, component 1" type="float" default="0"/>
	<input name="row4col2" description="row 4, component 2" type="float" default="0"/>
	<input name="row4col3" description="row 4, component 3" type="float" default="0"/>
    <input name="row4col4" description="row 4, component 4" type="float" default="0"/>
	<input name="usespace" description="Use named space reference" type="float" default="0"/>
    <input name="spacename" description="Reference named space" type="string" default="&quot;world&quot;"/>
    <output name="newmatrix" description="Matrix" type="matrix"/>
	<output name="spacename" description="Optional space name string" type="string"/>
    <rsl_code>
    #define usespace_$(usespace)
    #ifdef usespace_0
        $(mout) = matrix(	$(row1col1), $(row1col2), $(row1col3), $(row1col4),
							$(row2col1), $(row2col2), $(row2col3), $(row2col4),
							$(row3col1), $(row3col2), $(row3col3), $(row3col4),
							$(row4col1), $(row4col2), $(row4col3), $(row4col4));
     #else
        $(mout) = matrix $(spacename) (
							$(row1col1), $(row1col2), $(row1col3), $(row1col4),
							$(row2col1), $(row2col2), $(row2col3), $(row2col4),
							$(row3col1), $(row3col2), $(row3col3), $(row3col4),
							$(row4col1), $(row4col2), $(row4col3), $(row4col4));
    #endif /* usespace_$(usespace) */
	#undef usespace_$(usespace)
	
	$(mstr) = $(spacename);    
	</rsl_code>
	<usage>Assigns components to a (4x4 homogeneous transformation) matrix. Defaults to a zero matrix. A matrix can be constructed in reference to an existing named space, that can later be used for the transform, vtransform, ntransform functions. If &quot;usespace&quot; value is 1, then the matrix is built in reference to &quot;spacename&quot;. Please check your renderer&apos;s documentation for details regarding the matrix type and transformations.</usage>
</shrimp>

<shrimp type="function" name="Mtranslate" description="Translates matrix M" author="rconstruct">
    <input name="matrix" description="Matrix input" type="matrix" default="1"/>
	<input name="axis" description="Vector axis" type="vector" default="vector(1)"/>
    <output name="newmatrix" description="Translated matrix" type="matrix"/>
	<rsl_code>
		$(newmatrix) = translate( $(matrix), $(axis) );
	</rsl_code>
	<usage>Translates a matrix M. These functions are similar to the RI statements &quot;RiTranslate&quot;, &quot;RiRotate&quot;, and &quot;RiScale&quot;, except that the rotation angle in &quot;rotate&quot; is in radians, not in degrees as with &quot;RiRotate&quot;.</usage>
</shrimp>

<shrimp name="MPAtmos" type="function" description="Atmosphere shader message passing" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = atmosphere( $(parameter), $(result) );
	</rsl_code>
    <usage>You can use this function to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable, while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPAttr" type="function" description="Returns primitive attribute state data" author="rconstruct">
    <input name="parameter" description="Primitive attribute data to query, see usage." storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = attribute( $(parameter), $(result) );
	</rsl_code>
    <usage>Returns the data associated with a primitive&apos;s attribute state, as long as the data is known to the renderer and of correct type, in which case the result will contain the associated data content and &quot;attribute&quot; will exit with 1, otherwise, &quot;attribute&quot; will exit with 0. The data accessible by the &quot;attribute&quot; function is listed next, as well as its associated type: &quot;ShadingRate&quot;, uniform float; &quot;Sides&quot;, uniform float; &quot;Matte&quot;, uniform float; &quot;GeometricApproximation:motionfactor&quot;, uniform float; &quot;displacementbound:sphere&quot;, uniform float; &quot;displacementbound:coordinatesystem&quot;, uniform string; &quot;identifier:name&quot;, uniform string; &quot;grouping:membership&quot;, uniform string; &quot;trace:bias&quot;, uniform float: &quot;trace:displacements&quot;, uniform float; &quot;photon:shadingmodel&quot;, uniform string; &quot;photon:causticmap&quot;, uniform string; &quot;photon:globalmap&quot;, uniform string; &quot;photon:estimator&quot;, uniform float; &quot;visibility:camera&quot;, uniform float; &quot;visibility:trace&quot;, uniform float; &quot;visibility:transmission&quot;, uniform string; &quot;user:attributename&quot;, user set type. Notice that different renderer implementations of &quot;attribute&quot; might be able to access different data fields.</usage>
</shrimp>

<shrimp name="MPDisp" type="function" description="Displacement shader message passing" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = displacement( $(parameter), $(result) );
	</rsl_code>
    <usage>You use this function to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable, while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPIncid" type="function" description="Atmophere shader containing volume" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = incident( $(parameter), $(result) );
	</rsl_code>
    <usage>You can use this function to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possiblw, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPLight" type="function" description="Light shader message passing" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = lightsource( $(parameter), $(result) );
	</rsl_code>
    <usage>You use this to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPOppos" type="function" description="Atmosphere shader exterior volume" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="float color normal vector point string"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = opposite( $(parameter), $(result) );
	</rsl_code>
    <usage>You use this to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPOption" type="function" description="Returns renderer global option state data" author="rconstruct">
    <input name="parameter" description="Renderer option state to query, see help." storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="float color normal vector point string"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = option( $(parameter), $(result) );
	</rsl_code>
    <usage>Returns the data associated with the renderer&apos;s global option state, as long as the data is known to the renderer and of correct type in which case the result will contain the associated data content, and &quot;option&quot; will exit with 1, otherwise &quot;option&quot; will exit with 0. The data accessible by the &quot;option&quot; function is listed next, as well as its respective type: &quot;Format&quot;, uniform float[3]; &quot;FrameAspectRation&quot;, uniform float; &quot;CropWindow&quot;, uniform float[4]; &quot;DepthOfField&quot;, uniform float[3]; &quot;Shutter&quot;, uniform float[2]; &quot;Clipping&quot;, uniform float[2]; &quot;Hider&quot;, uniform string; &quot;DeviceResolution&quot;, uniform float[3]; &quot;trace:maxdepth&quot;, uniform float; &quot;trace:speculartreshold&quot;, uniform float; &quot;user:useroption&quot;, user set type, for user set options. Notice that different renderer implementations of &quot;option&quot; might be able to access different data fields. Have also in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should pay attention to the storage class of the data you&apos;re going to query.</usage>
</shrimp>

<shrimp name="MPSurf" type="function" description="Surface shader message passing" author="rconstruct">
    <input name="parameter" description="Shader parameter to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="float color normal vector point string"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = surface( $(parameter), $(result) );
	</rsl_code>
    <usage>You use this function to query the value of the parameter chosen on one of the shaders attached to the object being shaded. If there is a matching parameter and parameter type in a matching shader, then its value is stored in the output variable while the function exits with an return code of 1, otherwise the output variable retains its default value and the function returns 0. Note however that the &quot;lightsource&quot; function is only available inside &quot;illuminance&quot; blocks. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="Rayinfo" type="function" description="Provides information on the current ray" author="rconstruct">
    <input name="parameter" description="Ray info fields, see usage" storage="uniform" type="string" default="&quot;depth&quot;"/>
	<output name="status" description="Exit status" type="float"/>
	<output name="result" description="Query value" type="vector point string float"/>
	<rsl_code>
		$(status) = rayinfo( $(parameter), $(result) );
	</rsl_code>
	<usage>Returns the data associated with the current ray, as long as the data is known to the renderer and of correct type, in which case the result will contain the associated data content, and &quot;rayinfo&quot; will exit with 1, otherwise &quot;rayinfo&quot; will exit with 0. The data accessible by the &quot;rayinfo&quot; function varies with each renderer&apos;s implementation, please check your renderer&apos;s documentation for details. Usual information to query is: &quot;speculardepth&quot;, &quot;diffusedepth&quot;, &quot;shadowdepth&quot;, &quot;depth&quot;, &quot;type&quot;, &quot;label&quot;, &quot;origin&quot;, &quot;direction&quot;, &quot;length&quot;.</usage>
</shrimp>

<shrimp name="RendererInfo" type="function" description="Returns information about the renderer" author="rconstruct">
    <input name="parameter" description="Renderer data to query, see usage" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="color normal vector point string float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = rendererinfo( $(parameter), $(result) );
	</rsl_code>
    <usage>Returns information about the renderer, as long as the data queried is known to the renderer and of correct type in which case the result will contain the associated data content, and &quot;rendererinfo&quot; will exit with 1, otherwise &quot;rendererinfo&quot; will exit with 0. The data accessible by the &quot;rendererinfo&quot; function is listed next, as well as its type: &quot;renderer&quot;, uniform string; &quot;version&quot;, uniform float[4]; &quot;versionstring&quot;, uniform string. Notice that different renderer implementations of &quot;rendererinfo&quot; might be able to access different data fields. Have in mind that uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp name="Shadername" type="function" description="Name of the shader" author="rconstruct">
    <input name="shadertype" description="Shader type" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" storage="uniform" type="string"/>
	<rsl_code>
		$(result) = shadername( $(shadertype) );
	</rsl_code>
    <usage>Returns the name of the shader being evaluated, with possible shader type values being: &quot;displacement&quot;, &quot;lightsource&quot;, &quot;surface&quot;, &quot;atmosphere&quot;, &quot;interior&quot; and &quot;exterior&quot;. Returns an empty string if no shader of the specified shader type is assigned to the primitive being shaded.</usage>
</shrimp>

<shrimp name="TextureInfo" type="function" description="Returns information about the texture" author="rconstruct">
	<input name="texturemap" description="Texture name" storage="uniform" type="string" default="&quot;&quot;"/>
    <input name="parameter" description="Texture data to query, see usage" type="string" default="&quot;&quot;"/>
	<output name="result" description="Query value" type="string matrix float"/>
	<output name="status" description="Exit status" type="float"/>
	<rsl_code>
		$(status) = textureinfo( $(texturemap), $(parameter), $(result) );
	</rsl_code>
    <usage>Returns information about the supplied texture, if the data type being queried exists and is of the correct type, in which case status returns 1, otherwise status returns 0. The possible data fields and their respective types are: &quot;resolution&quot;, uniform float [2] - which returns the texture resolution; &quot;type&quot;, uniform string - which returns the type of the texture supplied (&quot;texture&quot;, &quot;shadow&quot;, &quot;environment&quot;); &quot;channels&quot;, uniform float - which returns the number of channels in the supplied texture; &quot;viewingmatrix&quot;, uniform matrix - returns a matrix, with the current to camera space transform used in the texture creation; &quot;projectionmatrix&quot;, uniform matrix - which returns a matrix with the current space to a 2d coordinate system in the [-1,1] range. Have in mind taht uniform to varying conversion is possible, however the reverse isn&apos;t, so you should consider the storage class of the variable you&apos;re going to query.</usage>
</shrimp>

<shrimp type="function" name="Constant" description="Passes input to output unchanged" author="rconstruct">
	<input name="in" description="Input" type_parent="value" type="float point vector normal string color" default="color(0)" />
	<output name="value" description="Output = Input" type="float point vector normal string color"/>
	<rsl_code>
		$(value) = $(in);
	</rsl_code>
	<usage>Useful for supplying multiple inputs with the same value.</usage>
</shrimp>

<shrimp type="function" name="FindPRhomb" description="Find Penrose rhomb" author="rconstruct">
	<input name="s" description="X value to sample" storage="varying" type="float" default="s"/>
	<input name="t" description="Y value to sample" storage="varying" type="float" default="t"/>
	<output name="tiled_s" description="out tile X" type="float"/>
	<output name="tiled_t" description="out tile Y" type="float"/>
	<output name="tiletype" description="Tile type" type="float"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		find_penrose_rhomb( $(tiled_s), $(tiled_t), $(tiletype), $(s), $(t) );
	</rsl_code>
	<usage>Penrose rhomb tile, by Derek Ledbetter, based on the projection method described in N. G. de Bruijn, &quot;Algebraic theory of Penrose&apos;s non-periodic tilings of the plane&quot;, in &quot;Proceedings of the Koninklijke Nederlandse Akademie van Wetenschappen&quot;, Series A, 84, 1981. This function returns Penrose rhomb tile values, and tile types, being 0 = skinny, and 1 = fat.</usage> 
</shrimp>

<shrimp type="function" name="LGMarble" description="Larry Gritz&apos;s marble veining function" author="rconstruct">
	<input name="veinfrequency" description="Veining frequency" type="float" default="1"/>
	<input name="veinlevels" description="Veining levels" type="float" default="2"/>
	<input name="warpfrequency" description="Warping frequency" type="float" default="1"/>
	<input name="warping" description="Warping intensity" type="float" default="0.5"/>
	<input name="sharpness" description="Sharpness" type="float" default="8"/>
	<input name="basecolor" description="Base color" type="color" default="color( .12, .22, .27 )"/>
	<input name="veincolor" description="Veining color" type="color" default="color( .37, .58, .37 )"/>
	<input name="P" description="Surface point" type="point" default="P"/>
	<output name="value" description="Output color" type="color"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
		$(value) = veinedmarble(	$(veinfrequency), $(veinlevels),
									$(warpfrequency), $(warping),
									$(sharpness), $(basecolor),
									$(veincolor), $(P) );
	</rsl_code>
	<usage>Larry Gritz&apos;s LGMarble veining pattern, mixing basecolor to veincolor. Have in mind that &quot;pp&quot; is transformed to &quot;shader&quot; space in the function - see the header for more information.</usage> 
</shrimp>

<shrimp type="function" name="Mandelbrot" description="Mandelbrot fractal, by Michael Rivero" author="rconstruct">
	<input name="iterations" description="Maximum number of iterations" type="float" default="500"/>
	<input name="useuv" description="Use UV instead of ST" type="float" default="0"/>
	<output name="value" description="Output color" type="color"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
        $(value) = mrrand( $(iterations), $(useuv) );
	</rsl_code>
	<usage>Michael Rivero&apos;s Mandelbrot fractal shader. &quot;Iterations&quot; defines the maximum number of iterations, and &quot;useuv&quot; = 1/0 toggles between using UV surface parameters and ST surface texture parameters.</usage>
</shrimp>

<shrimp type="function" name="Oak" description="Larry Gritz&apos;s Oak pattern" author="rconstruct">
	<input name="ringfreq" description="Mean frequency of ring spacing" type="float" default="0.14"/>
    <input name="unevenness" description="Uneveness of rings distribution" type="float" default="0.65"/>
    <input name="grainfreq" description="Frequency of wood fine grain" type="float" default="0.9"/>
    <input name="ringnoise" description="General warping of the domain" type="float" default="3"/>
    <input name="noisefreq" description="Ring noise frequency" type="float" default="0.5"/>
    <input name="trunkwobble" description="Trunk axis wobble control" type="float" default="2"/>
    <input name="wobblefreq" description="Trunk axis wobble frequency" type="float" default="0.23"/>
    <input name="angularwobble" description="Warping by angle about Z axis" type="float" default="0.35"/>
    <input name="angularfreq" description="Z axis warping frequency" type="float" default="0.9"/>
    <input name="ringweight" description="Rings weight scale" type="float" default="1"/>
    <input name="grainweight" description="Grain weight scale" type="float" default="1"/>
    <input name="P" description="Surface point to be evaluated" type="point" default="P"/>
	<output name="value" description="Output color" type="color"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
        $(value) = oaktexture(	$(P), $(ringfreq), $(unevenness),
								$(grainfreq), $(ringnoise),
								$(noisefreq), $(trunkwobble),
								$(wobblefreq), $(angularwobble),
								$(angularfreq), $(ringweight),
								$(grainweight) );
	</rsl_code>
	<usage>Larry Gritz&apos;s oak pattern function. &quot;ringfreq&quot; controls the frequency of ring spacing. &quot;unevenness&quot; controls the rings distribution, 0 being equally spaced rings, and higher values unequally spaced rings. &quot;Grainfreq&quot;, controls the frequency of the wood fine grain. &quot;Ringnoise&quot; and &quot;noisefreq&quot;, control the warping of the domain. &quot;Trunkwobble&quot; and &quot;wobblefreq&quot;, controls the noise that wobbles the axis of the trunk, so that it isn&apos;t perfectly aligned on the z axis. &quot;Angularwobble&quot; and &quot;angularfreq&quot;, control the warping indexed by angle about the z axis. &quot;ringweight&quot; and &quot;grainweight&quot;, control the overall scale to which rings and grain are weighted, 0 being a null effect, and 1 being a full effect. This block returns 0 when in the background light wood, and 1 when in the darkest part of a ring or grain.</usage>
</shrimp>

<shrimp type="function" name="PaintedPenrose" description="Painted Penrose rhomb tile" author="rconstruct">
	<input name="s" description="X value to sample" storage="varying" type="float" default="s"/>
	<input name="t" description="Y value to sample" storage="varying" type="float" default="t"/>
	<input name="tilesize" description="Tile size" type="float" default="1"/>
	<input name="skinnycolor" description="Skinny color" type="color" default="color( 0.2, 0.4, 0.65 )"/>
	<input name="fatcolor" description="Fat color" type="color" default="color( 0.92, 0.33, 0.61 )"/>
	<output name="value" description="Output color" type="color"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
		$(value) = painted_tiling( $(s), $(t), $(tilesize), $(skinnycolor), $(fatcolor) );
	</rsl_code>
	<usage>Painted Penrose rhomb tiles, by Derek Ledbetter.</usage>
</shrimp>

<shrimp type="function" name="Voronoi" description="Voronoi example" author="rconstruct">
	<input name="P" description="point to sample Voronoi at" type="point" default="P"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
	<input name="metric" description="Distance metric, see usage" storage="uniform" type="float" default="2"/>
    <input name="squiggliness" description="Squiggliness" type="float" default="2"/>
    <input name="frequency" description="Frequency" type="float" default="10"/>
    <input name="scale" description="Scale" type="float" default="2"/>
    <input name="thickness" description="Line thickness" type="float" default="0.02"/>
    <input name="filterwidth" description="fBm filter width" type="float" default="4"/>
    <input name="octaves" description="fBm octaves" storage="uniform" type="float" default="2"/>
    <input name="lacunarity" description="fBm lacunarity" storage="uniform" type="float" default="0.05"/>
    <input name="gain" description="fBm gain" storage="uniform" type="float" default="0.5"/>
    <input name="coordsystem" description="Coordinate space" storage="uniform" type="string" default="&quot;shader&quot;"/>
    <output name="Ci" description="Output color" type="color"/>
    <output name="feature1" description="1st feature" storage="varying" type="float"/>
    <output name="feature2" description="2nd feature" storage="varying" type="float" />
    <output name="position1" description="1st position" storage="varying" type="point" />
    <output name="position2" description="2nd position" storage="varying" type="point" />	
    <output name="scalefactor" description="scale factor" type="float" />
	<rsl_include>rsl_fractal.h</rsl_include>
	<rsl_code>
		point po_$(blockname) = transform( $(coordsystem), $(P) );
		point pp_$(blockname) = po_$(blockname) / $(scale) + $(squiggliness)
							* vfBm(	po_$(blockname) / $(scale) * $(frequency),
								$(filterwidth), $(octaves), $(lacunarity), $(gain) );

		voronoi_f1f2_3d(	pp_$(blockname), $(jittering), $(metric), $(feature1),
							$(feature2), $(position1), $(position2) );

		color cc_$(blockname) = color cellnoise( vector(10,0,0) + $(position1) );
		$(scalefactor) = distance( $(position1), $(position2) ) /
							distance( $(position1), pp_$(blockname)) +
							distance( pp_$(blockname), $(position2) );

		cc_$(blockname) *= step( $(thickness) * $(scalefactor), $(feature2) - $(feature1) );

		$(Ci) = cc_$(blockname);
	</rsl_code>
	<usage>Voronoi example shader. Can be constructed with the cell noise and Voronoi blocks, as can be seen in an example scene, but it&apos;ll be provided in a block form for convenience as well. When &quot;metric&quot; = 0, distance metric is Tchebychev, when different than 0, then the distance metric = Minkowski, being &quot;metric&quot;, Minkowski&apos;s P parameter, with P = 1 as the Manhattan metric, P = 2, the Euclidian metric, and allowing higher orders of P, as P increases, towards Tchebychev results. The &quot;coordsystem&quot; variable defaults to &quot;shader&quot; space, so the supplied points are transformed from &quot;current&quot; to &quot;shader&quot; space by default.</usage> 
</shrimp>

<shrimp type="function" name="VoronoiKM2D2F" description="2D Voronoi noise, 2 features, Karlsruhe (Moscow) metric" author="rconstruct">
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
    <input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="jittering" description="Jitter" type="float" default="1"/>
    <output name="feature1" description="feature 1" type="float"/>
    <output name="s1" description="s position 1" type="float"/>
    <output name="t1" description="t position 1" type="float"/>
    <output name="feature2" description="feature 2" type="float"/>
    <output name="s2" description="s position 2" type="float"/>
    <output name="t2" description="t position 2" type="float"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
		/* initialize */
		$(feature1) = 0; $(s1) = 0; $(t1) = 0;
		$(feature2) = 0; $(s2) = 0; $(t2) = 0;
	    voronoi_km_f1f2_2d( $(s), $(t), $(jittering), $(feature1),
							$(s1), $(t1), $(feature2), $(s2), $(t2));
	</rsl_code>
	<usage>2D Voronoi cell noise, 2 feature version, using Karlsruhe (Moscow) distance metric.</usage> 
</shrimp>

<shrimp type="function" name="Wood" description="Wood rings pattern" author="rconstruct">
	<input name="ringscale" description="Ring scale factor" type="float" default="15"/>
	<input name="texscale" description="Texture scale" type="float" default="1"/>
	<input name="graininess" description="graininessness" type="float" default="1"/>
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<output name="value" description="Output color" type="float"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
        $(value) = wood2( $(ringscale), $(texscale), $(graininess), $(P) );
	</rsl_code>
	<usage>Wood pattern block, based on wood2.sl shader by Larry Gritz. &quot;Texscale&quot; controls the overall scaling for the texture; &quot;ringscale&quot; controls the scaling for the wood rings spacing; &quot;graininess&quot; controls the relative graininess with 0 having no fine grain. The supplied surface point &quot;pp&quot; is transformed to &quot;shader&quot; space in this function, see header for more details.</usage>
</shrimp>

<shrimp type="function" name="Blotches" description="Generates blotches" author="rconstruct">
	<input name="P" description="Surface point to evaluate" storage="varying" type="point" default="P"/>
	<input name="radius" description="Blotch radius" type="float" default="0.15"/>
	<input name="frequency" description="Frequency" type="float" default="1"/>
	<input name="offset" description="Offset" type="float" default="0.35"/>
	<input name="jittering" description="Jittering" type="float" default="0.65"/>
	<input name="metric" description="Voronoi distance metric" storage="uniform" type="float" default="2"/>
	<output name="value" description="Output value" type="float"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
		$(value) = blotches(	$(radius), $(frequency), $(offset), $(jittering),
								$(metric), $(P) );
	</rsl_code>
	<usage>Generates random blotches, based on single feature Voronoi cell noise. &quot;Jittering&quot; controls the Voronoi cell noise jittering, generating a less or more evenly distribution of blotches. &quot;Offset&quot; controls the center offset, a value of 0 generating a hollow blotch, and 1.0 an solid blotch. &quot;Radius&quot; controls the radius, and &quot;frequency&quot;, the frequency of the blotches. &quot;Metric&quot; controls the distance metric used for the Voronoi noise, when different than 0 the metric being the Minkowski metric, with &quot;metric&quot; as Minkowski&apos;s P parameter, being P = 1, the Manhattan metric, P = 2 the Euclidian metric, and allowing higher orders of P tending towards Tchebychev results.</usage>
</shrimp>

<shrimp type="function" name="Brick" description="Larry Gritz&apos;s brick tiling pattern" author="rconstruct">
	<input name="s" description="X point to be tested" storage="varying" type="float" default="s"/>
	<input name="t" description="Y point to be tested" storage="varying" type="float" default="t"/>
    <input name="tilewidth" description="Tile width" storage="uniform" type="float" default="0.6"/>
    <input name="tileheight" description="Tile height" storage="uniform" type="float" default="0.2"/>
    <input name="staggering" description="Row stagger" storage="uniform" type="float" default="0.2"/>
    <input name="variation" description="Row stagger variation" storage="uniform" type="float" default="0.4"/>
    <input name="frequency" description="Edge noise frequency" storage="uniform" type="float" default="2"/>
    <input name="amplitude" description="Edge noise amplitude" storage="uniform" type="float" default="0.5"/>
    <output name="row" description="Output row" type="float"/>
    <output name="column" description="Output column" type="float"/>
    <output name="stile" description="X position with this tile" type="float"/>
    <output name="ttile" description="Y position with this tile" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		basicbrick( $(s), $(t), $(tilewidth), $(tileheight), $(staggering),
					$(variation), $(frequency), $(amplitude),
					$(column), $(row), $(stile), $(ttile) );
	</rsl_code>
	<usage>Larry Gritz&apos;s basic brick tiling pattern function. &quot;S&quot; and &quot;t&quot; are respectively the s and t coordinates of the surface, &quot;tilewidth&quot; and &quot;tileheight&quot; are the dimensions of each tile. &quot;staggering&quot; controls the row stagger relative to the previous row, and &quot;variation&quot; defines how much &quot;staggering&quot; should randomly vary. &quot;frequency&quot; and &quot;amplitude&quot; define the frequency and amplitude of the noise added to the edge between tiles. This block outputs the row and column indexes of which tile the sample is in, and the position x and y coords within this tile, in the [0,1] range.</usage>
</shrimp>

<shrimp type="function" name="CellContour" description="Generates contour lines of shaded cells" author="rconstruct">
	<input name="position1" description="First point position" type="point" default="point(0)"/>
	<input name="position2" description="Second point position" type="point" default="point(1)"/>
	<input name="feature1" description="Primary feature" type="float" default="0"/>
	<input name="feature2" description="Secondary feature" type="float" default="1"/>
	<input name="thickness" description="Contour line thickness" type="float" default="15"/>
	<input name="P" description="Surface point" type="point" default="P"/>
	<output name="value" description="Output value" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = step( $(thickness) * (
					distance( $(position1), $(position2) ) / (
					distance( $(position1), $(P) ) + distance( $(P),
					$(position2) ))) , $(feature2) - $(feature1) );
	</rsl_code>
	<usage>This function generates contour lines on shaded cells.</usage>
</shrimp>

<shrimp type="function" name="Disc" description="Returns 1 if inside the disc, otherwise returns 0" author="rconstruct">
	<input name="s" description="X surface coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Y surface coordinate" storage="varying" type="float" default="t"/>
	<input name="xcenter" description="X component of disc center" type="float" default="0.5"/>
	<input name="ycenter" description="Y component of disc center" type="float" default="0.5"/>
	<input name="radius" description="The radius of the disc" type="float" default="0.2"/>
	<input name="blur" description="The amount the edge is to be blurred" type="float" default="0.001"/>
	<output name="value" description="returns 1 if x,y lies within the disc" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		$(value) = shDisc(	$(xcenter), $(ycenter), $(s), $(t),
							$(radius), $(blur) );
	</rsl_code>
	<usage>Tests whether a 2D point lies inside a 2D Disc. Blur can be used to control the antialiasing. The output varies smoothly between 0 and 1 in the blurred region.</usage>
</shrimp>

<shrimp type="function" name="FPulsetrain" description="Larry Gritz&apos;s filtered pulsetrain" author="rconstruct">
	<input name="x" description="Value to test" storage="varying" type="float" default="s"/>
	<input name="edge" description="Edge" type="float" default="0.2"/>
	<input name="period" description="Period" type="float" default="1"/>
	<input name="filterwidth" description="Filter width" type="float" default="0.1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = filteredpulsetrain( $(edge), $(period), $(x), $(filterwidth) );
	</rsl_code>
	<usage>An antialiased version of the &quot;pulsetrain&quot; function, which generates a signal that repeats with a given period, and is 0 when 0 &lt;=mod(x,period)&lt;edge, and 1 when mod(x,period)&gt;edge. The antialiased version takes into account that the filter may cover multiple pulses in the train.</usage>
</shrimp>

<shrimp type="function" name="FSmoothpulse" description="Larry Gritz&apos;s filtered smoothpulse" author="rconstruct">
	<input name="x" description="Value to test" storage="varying" type="float" default="s"/>
	<input name="minimum1" description="First minimum" type="float" default="0"/>
	<input name="maximum1" description="First maximum" type="float" default="0.3"/>
	<input name="minimum2" description="Second minimum" type="float" default="0.7"/>
	<input name="maximum2" description="Second maximum" type="float" default="1"/>
	<input name="filterwidth" description="Filter width" type="float" default="0.1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = filteredsmoothpulse(	$(minimum1), $(maximum1), $(minimum2),
										$(maximum2), $(x), $(filterwidth));
	</rsl_code>
	<usage>Antialiased version of &quot;smoothpulse&quot; by Larry Gritz. Returns filteredsmoothstep(e0, e1, x, dx) - filteredsmoothstep( e2, e3, x, dx).</usage>
</shrimp>

<shrimp type="function" name="FWidth" description="Determine correct sample size for antialiasing" author="rconstruct">
	<input name="P" description="point under consideration" storage="varying" type="float point" default="P"/>
	<output name="filterwidth" description="An estimate of the sample width at p" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
	#define $(blockname)_$(P:type)
	#ifdef $(blockname)_float
		$(filterwidth) = filterwidth( $(P) );
	#else
		$(filterwidth) = filterwidthp( $(P) );
	#endif /* $(blockname)_$(P:type) */
	#undef $(blockname)_$(P:type)
	</rsl_code>
	<usage>The filterwidth function takes a float, or point inputs, and returns the approximate amount that the float or point changes from pixel to adjacent pixel. It&apos;s used to filter frequencies that would otherwise produce aliasing.</usage>
</shrimp>

<shrimp type="function" name="HexTile" description="Hexagonal tiling" author="rconstruct">
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="tileradius" description="Tile radius" type="float" default="0.2"/>
	<input name="mortarwidth" description="Mortar width" type="float" default="0.02"/>
	<input name="variation" description="Tile variation" type="float" default="0.15"/>
	<output name="mortar" description="Output mortar" type="float"/>
	<output name="tileindex" description="Tile index" type="float"/>
	<rsl_include>rsl_extrapatterns.h</rsl_include>
	<rsl_code>
		hextile(	$(tileradius), $(mortarwidth), $(variation), $(s), $(t),
					$(mortar), $(tileindex) );
	</rsl_code>
	<usage>Hexagonal tiling block, based on LGHexTile.sl by Larry Gritz.</usage>
</shrimp>

<shrimp type="function" name="Line" description="Returns 1 if on the line, otherwise 0" author="rconstruct">
	<input name="s" description="X coordinate of point to be tested" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate of point to be tested" storage="varying" type="float" default="t"/>
	<input name="x0" description="X coordinate of the 1st endpoint of the line" type="float" default="0"/>
	<input name="y0" description="Y coordiante of the 1st endpoint of the line" type="float" default="0"/>
	<input name="x1" description="X coordinate of the 2nd endpoint of the line" type="float" default="1"/>
	<input name="y1" description="Y coordinate of the 2nd endpoint of the line" type="float" default="1"/>
	<input name="thickness" description="The thickness of the line" type="float" default="0.1"/>
	<input name="blur" description="The amount the edge is to be blurred" type="float" default="0.001"/>
	<output name="value" description="Returns 1 if X,Y lies on the line" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		$(value) = shLine(	$(x0), $(y0), $(x1), $(y1),
							$(s), $(t), $(thickness), $(blur) );
	</rsl_code>
	<usage>This function tests whether a 2D point lines on a 2D line. Blur can be used to control the antialiasing. The output varies smoothly between 0 and 1 in the blurred regions.</usage>
</shrimp>

<shrimp type="function" name="Pulsetrain" description="Larry Gritz&apos;s pulsetrain" author="rconstruct">
	<input name="x" description="Value to test" storage="varying" type="float" default="s"/>
	<input name="edge" description="Edge" type="float" default="0.2"/>
	<input name="period" description="Period" type="float" default="1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = pulsetrain( $(edge), $(period), $(x) );
	</rsl_code>
	<usage>Larry Gritz&apos;s &quot;pulsetrain&quot;, generates a signal that repeats with a given period, and is i when 0 &lt;=mod(x,period)&lt;edge, and 1 when mod(x,period)&gt;edge.</usage>
</shrimp>

<shrimp type="function" name="Rect" description="Returns 1 if in the Rectangle, otherwise 0" author="rconstruct">
	<input name="s" description="X point to be tested" storage="varying" type="float" default="s"/>
	<input name="t" description="Y point to be tested" storage="varying" type="float" default="t"/>
	<input name="x0" description="Top left X coord of the rectangle" type="float" default="0.3"/>
	<input name="y0" description="Top left Y coord of the rectangle" type="float" default="0.3"/>
	<input name="width" description="The width of the rectangle" type="float" default="0.5"/>
	<input name="height" description="The height of the rectangle" type="float" default="0.3"/>
	<input name="blur" description="The amount the edge is to be blurred" type="float" default="0.001"/>
	<output name="value" description="returns 1 if X,Y lies within the rectangle" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		$(value) = shRect(	$(x0), $(y0), $(s), $(t),
							$(width), $(height), $(blur) );
	</rsl_code>
	<usage>This function tests whether a 2D point lines inside a 2D rectangle. Blur can be used to control the antialiasing. The output varies smoothly between 0 and 1 in the blurred region.</usage>
</shrimp>

<shrimp type="function" name="Ring" description="Returns 1 if in the Ring, otherwise 0" author="rconstruct">
	<input name="s" description="X coordinate of point to test" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate of point to test" storage="varying" type="float" default="t"/>
	<input name="xcenter" description="ox,oy give the centre of the ring" type="float" default="0.5"/>
	<input name="ycenter" description="ox,oy give the centre of the ring" type="float" default="0.5"/>
	<input name="radius" description="The radius of the disc" type="float" default="0.3"/>
	<input name="thickness" description="The thickness of the ring" type="float" default="0.1"/>
	<input name="blur" description="The amount the edge is to be blurred" type="float" default="0.001"/>
	<output name="value" description="returns 1 if x,y lies within the ring" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		$(value) = shRing(	$(xcenter), $(ycenter), $(s), $(t),
							$(radius), $(thickness), $(blur) );
	</rsl_code>
	<usage>This function tests whether a 2D point lies inside a 2D torus shape. Blur can be used to control the antialiasing. The output varies smoothly between 0 and 1 in the blurred regions.</usage>
</shrimp>

<shrimp type="function" name="Sawtooth" description="Generates a sawtooth wave" author="rconstruct">
	<input name = "x" description="Value to sample the wave at" storage="varying" type="float" default="s"/>
	<input name = "amplitude" description="Amplitude of the wave" type="float" default="1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_code>
		$(value) = $(amplitude) * mod( $(x), 1 );
	</rsl_code>
	<usage>This function generates a sawtooth wave.</usage>
</shrimp>

<shrimp type="function" name="Smoothpulse" description="Larry Gritz&apos;s smoothpulse" author="rconstruct">
	<input name="x" description="Value to test" storage="varying" type="float" default="s"/>
	<input name="minimum1" description="E0" type="float" default="0"/>
	<input name="maximum1" description="E1" type="float" default="0.3"/>
	<input name="minimum2" description="E2" type="float" default="0.7"/>
	<input name="maximum2" description="E3" type="float" default="1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = smoothpulse( $(minimum1), $(maximum1), $(minimum2), $(maximum2), $(x) );
	</rsl_code>
	<usage>Larry Gritz&apos;s &quot;smoothpulse&quot; function, returns smoothstep(e0,e1,x)-smoothstep(e2,e3,x).</usage>
</shrimp>

<shrimp type="function" name="Smoothpulsetrain" description="Larry Gritz&apos;s smoothpulsetrain" author="rconstruct">
	<input name="x" description="Value to test" storage="varying" type="float" default="s"/>
	<input name="minimum1" description="First minimum" type="float" default="0"/>
	<input name="maximum1" description="First maximum" type="float" default="1"/>
	<input name="minimum2" description="Second minimum" type="float" default="0.2"/>
	<input name="maximum2" description="Second maximum" type="float" default="0.8"/>
	<input name="period" description="Period" type="float" default="1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_code>
		$(value) = smoothpulsetrain(	$(minimum1), $(maximum1), $(minimum2),
										$(maximum2), $(period), $(x) );
	</rsl_code>
	<usage>Larry Gritz&apos;s &quot;smoothpulsetrain&quot;, generates a pulse train of &quot;smoothstep&quot;s, a signal that repeats with a given period, and is 0 when 0&lt;=mod(x/period,1)&lt;edge, and 1 when mod(x/period,1)&gt;edge.</usage>
</shrimp>

<shrimp type="function" name="Stripe" description="Repeating stripe pattern" author="rconstruct">
	<input name="x" description="x is the value to be tested" storage="varying" type="float" default="s"/>
	<input name="frequency" description="The frequency of the stripe" type="float" default="1"/>
	<input name="width" description="The width of the stripe" type="float" default="0.5"/>
	<input name="blur" description="The amount of blur" type="float" default="0.001"/>
	<output name="value" description="1 if x is in the stripe, 0 if in between stripes" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		$(value) = shStripe( $(width), $(frequency), $(x), $(blur) );
	</rsl_code>
	<usage>This function generates stripes of width &quot;width&quot; at the given frequency &quot;frequency&quot; for the &quot;x&quot; value to be tested, with &quot;blur&quot; controlling the antialiasing of the stripe edges.</usage>
</shrimp>

<shrimp type="function" name="Tile" description="Simple tiling function" author="rconstruct">
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="xfrequency" description="The frequency of the tiling in the x direction" storage="uniform" type="float" default="1"/>
	<input name="yfrequency" description="The frequency of the tiling in the y direction" storage="uniform" type="float" default="1"/>
	<output name="xtile" description="The x coordinate inside the tile" type="float"/>
	<output name="ytile" description="The y coordinate inside the tile" type="float"/>
	<output name="column" description="The column number of the current tile" type="float"/>
	<output name="row" description="The row number of the current tile" type="float"/>
	<rsl_include>rsl_helpers.h</rsl_include>
	<rsl_include>rsl_shapes.h</rsl_include>
	<rsl_code>
		shTile( $(s), $(t), $(xfrequency), $(yfrequency), $(xtile), $(ytile),
				$(column), $(row) );
	</rsl_code>
	<usage>This function takes a point X,Y and returns the coordinates inside the tile (&quot;xtile&quot;,&quot;ytile&quot;) and the tile &quot;column&quot; and &quot;row&quot;, with &quot;xfrequency&quot; and &quot;yfrequency&quot; affecting the frequency (and consequently the shape) of the tiles in the X and Y directions.</usage>
</shrimp>

<shrimp type="function" name="Triangle" description="Generates a Triangle wave" author="rconstruct">
	<input name = "x" description="Value to sample the wave at" storage="varying" type="float" default="s"/>
	<input name = "amplitude" description="Amplitude of the wave" type="float" default="1"/>
	<output name="value" description="Value of the wave at x" type="float"/>
	<rsl_code>
		$(value) = $(amplitude) * 2*abs( 0.5 - mod( $(x), 1 ) );
	</rsl_code>
	<usage>This function generates a triangle wave.</usage>
</shrimp>

<shrimp name="Caustic" type="function" description="Returns caustic on surface point" author="rconstruct">
    <input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<output name="Ci" description="Caustic value" type="color"/>
	<rsl_code>
	
	#if RENDERER == pixie || RENDERER == _3delight
		/* get estimator and caustic map via attribute() */
		uniform float estimator_$(blockname) = 100;
		uniform string cmap_$(blockname) = "";
		attribute(&quot;photon:estimator&quot;, estimator_$(blockname) );
		if (1 == attribute(&quot;photon:causticmap&quot;,
			cmap_$(blockname) ) &amp;&amp;
			cmap_$(blockname) != &quot;&quot; ) {
			aov_caustics += photonmap(	cmap_$(blockname), $(P), $(N),
							&quot;estimator&quot;, estimator_$(blockname) );
		}
	#elif RENDERER == aqsis /* do nothing (0) */
	#else
		/* color caustic() on PRMan and Air */
		aov_caustics += color caustic( $(P), $(N) );
	#endif /* RENDERER */
		$(Ci) = aov_caustics;

	</rsl_code>
    <usage>This function returns caustics from a caustic photon map lookup, on a surface area defined by surface point &quot;P&quot; and surface normal &quot;N&quot;. This can be done also using &quot;photonmap&quot;, retrieving the caustics map and the photon estimator via &quot;attribute&quot; function, as the &quot;caustic&quot; function does. The caustics value is passed to &quot;aov_caustics&quot; AOV preset.</usage>
</shrimp>

<shrimp name="IndirectDiffuse" type="function" description="Computes indirect lighting" author="rconstruct" rolled="1">
    <input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="direction" description="Direction" storage="varying" type="vector normal" default="faceforward( normalize(N), normalize(I))"/>
	<input name="adaptive" description="Turns adaptive sampling on/off" storage="uniform" type="float" default="1"/>
	<input name="minsamples" description="Minimum number of samples to use" storage="uniform" type="float" default="16"/>
	<input name="falloffmode" description="Falloff mode, 0 = exponential, 1 = polynomial" storage="uniform" type="float" default="0"/>
	<input name="falloff" description="Falloff, 0 = no falloff, 1 = linear falloff" storage="uniform" type="float" default="0"/>
    <input name="samples" description="Samples" type="float" default="32"/>
	<input name="samplebase" description="Controls ray origin jittering" storage="uniform" type="float" default="1"/>
    <input name="maxdist" description="Maximum distance" storage="uniform" type="float" default="1e38"/>
	<input name="maxpixeldist" description="Maximum samples distance" type="float" default="-1"/>
	<input name="maxsolidangle" description="Maximum solid angle, in steradians" storage="uniform" type="float" default="0.05"/>
	<input name="maxerror" description="Quality vs speed" type="float" default="-1"/>
	<input name="bias" description="Bias to control self-intersection" type="float" default="0.01"/>
	<input name="coneangle" description="Cone angle" storage="uniform" type="float" default="1.570796327"/>
	<input name="axis" description="Direction of light casting hemisphere" storage="uniform" type="vector" default="vector(0)"/>
	<input name="distribution" description="Distribution" storage="uniform" type="string" default="&quot;cosine&quot;"/>
	<input name="hitsides" description="Side of surface to consider by a ray hit" storage="uniform" type="string" default="&quot;front&quot;"/>
	<input name="hitmode" description="Ray hit mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="label" description="Ray lavel" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Objects subset considered" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envmap" description="Environment map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="useptc" description="Toggle point based irradiance" storage="uniform" type="float" default="0"/>
	<input name="ptcfile" description="Point cloud filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="coordsys" description="Point cloud coordinate system" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="clamp" description="Clamp excessive occlusion" storage="uniform" type="float" default="0"/>
	<input name="sortbleeding" description="Sort bleeding" storage="uniform" type="float" default="0"/>
	<output name="Ci" description="Occlusion value" storage="varying" type="color" />
	<output name="Envcolor" description="Environment color lookup result" storage="varying" type="color" />
	<output name="Envdirection" description="Average unoccluded direction" storage="varying" type="vector" />
	<output name="Occlusion" description="Occlusion amount" storage="varying" type="float" />
	<rsl_code>
	
	/* initialize */
	$(Envcolor) = color(0); $(Envdirection) = vector(0); $(Occlusion) = 0;

	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif /* SHADEOP_ARGUMENTS */

	#if RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	"label", $(label), "subset", $(subset), \
								"bias", $(bias), "hitmode", $(hitmode), \
								"coneangle", $(coneangle), "axis", $(axis), \
								"samplebase", $(samplebase), \
								"maxdist", $(maxdist), \
								"environmentmap", $(envmap), \
								"environmentspace", $(envspace), \
								"distribution", $(distribution), \
								"adaptive", $(adaptive), \
								"minsamples", $(minsamples), \
								"falloffmode", $(falloffmode), \
								"falloff", $(falloff), \
								"pointbased", $(useptc), "filename", $(ptcfile), \
								"hitsides", $(hitsides), \
								"maxsolidangle", $(maxsolidangle), \
								"clamp", $(clamp), \
								"sortbleeding", $(sortbleeding), \
								"coordsystem", $(coordsys), "occlusion", $(Occlusion)
	#elif RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"coordsystem", $(coordsys), \
								"maxdist", $(maxdist), \
								"coneangle", $(coneangle), \
								"samplebase", $(samplebase), \
								"label", $(label), "bias", $(bias), \
								"maxerror", $(maxerror), \
								"pointbased", $(useptc), \
								"environmentmap", $(envmap), \
								"filename", $(ptcfile), \
								"maxpixeldist", $(maxpixeldist), \
								"maxsolidangle", $(maxsolidangle), \
								"occlusion", $(Occlusion)
	#elif RENDERER == prman
	#define SHADEOP_ARGUMENTS	"adapt", $(adaptive), "minsamples", $(minsamples), \
								"coordsystem", $(coordsys), \
								"distribution", $(distribution), \
								"maxdist", $(maxdist), \
								"falloffmode", $(falloffmode), \
								"falloff", $(falloff), \
								"coneangle", $(coneangle), \
								"samplebase", $(samplebase), \
								"hitmode", $(hitmode), \
								"hitsides", $(hitsides), "subset", $(subset), \
								"label", $(label), \
								"environmentmap", $(envmap), \
								"environmentspace", $(envspace), \
								"bias", $(bias), \
								"maxpixeldist", $(maxpixeldist), \
								"maxerror", $(maxerror), \
								"pointbased", $(useptc), \
								"filename", $(ptcfile), \
								"maxsolidangle", $(maxsolidangle), \
								"clamp", $(clamp), \
								"environmentcolor", $(Envcolor), \
								"environmentdir", $(Envdirection), \
								"occlusion", $(Occlusion)	
	#elif RENDERER == air
	#define SHADEOP_ARGUMENTS	"environmentmap", $(envmap), \
								"environmentspace", $(envspace), \
								"label", $(label), "subset", $(subset)
	#else /* no indirectdiffuse() available */
	#define NOSHADEOP /* what about bmrt, entropy, renderdotc? */
	#endif /* RENDERER */

	#ifdef NOSHADEOP
		$(Ci) = color(0);
	#else
		aov_indirectdiffuse += indirectdiffuse(	$(P), $(direction),
												$(samples), SHADEOP_ARGUMENTS );
		aov_occlusion += $(Occlusion);
		$(Ci) = aov_indirectdiffuse;
		$(Occlusion) = 1 - $(Occlusion);
	#endif /* NOSHADEOP */
	
	#undef NOSHADEOP
	#undef SHADEOP_ARGUMENTS
	
	</rsl_code>
    <usage>Indirect diffuse retrieves the diffuse illumination from indirect light, allowing effects such as color bleeding.  Coneangle defaults to PI/2. Distribution can be one of &quot;cosine&quot; or &quot;uniform&quot;, defaulting to &quot;cosine&quot;. This function can use an optional environment map to use when rays don&apos;t hit the geometry. You can also use point-based &quot;indirectdiffuse&quot;. Note that this function varies considerably from implementation to implementation, so please consult your renderer&apos;s documentation for details. This function passes the indirect diffuse value into the &quot;aov_indirectdiffuse&quot;, and the optional occlusion value into the &quot;aov_occlusion&quot; AOV presets (as occlusion, not 1 - occlusion).</usage>
</shrimp>

<shrimp name="Occlusion" type="function" description="Ambient occlusion function" author="rconstruct" rolled="1">
    <input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="direction" description="Direction" storage="varying" type="vector normal" default="faceforward( normalize(N), normalize(I))"/>
	<input name="adaptive" description="Turns adaptive sampling on/off" storage="uniform" type="float" default="1"/>
	<input name="minsamples" description="Minimum number of samples to use" storage="uniform" type="float" default="16"/>	
    <input name="samples" description="Samples" type="float" default="32"/>
	<input name="samplebase" description="Controls ray origin jittering" storage="uniform" type="float" default="1"/>
    <input name="maxdist" description="Maximum distance" storage="uniform" type="float" default="1e38"/>
	<input name="maxpixeldist" description="Maximum samples distance" type="float" default="-1"/>
	<input name="maxsolidang" description="Maximum solid angle, in steradians" storage="uniform" type="float" default="0.05"/>
	<input name="maxerror" description="Quality vs speed" type="float" default="-1"/>
	<input name="bias" description="Bias to control self-intersection" type="float" default="0.01" />
	<input name="coneangle" description="Cone angle" storage="uniform" type="float" default="1.570796327"/>
	<input name="axis" description="Direction of light casting hemisphere" storage="uniform" type="vector" default="vector(0)"/>
	<input name="distribution" description="Distribution" storage="uniform" type="string" default="&quot;cosine&quot;"/>
	<input name="hitsides" description="Side of surface to consider by a ray hit" storage="uniform" type="string" default="&quot;front&quot;"/>
	<input name="hitmode" description="Ray hit mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="label" description="Ray lavel" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Objects subset considered" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envmap" description="Environment map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="occlmap" description="Occlusion map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="blur" description="Shadow map blur" type="float" default="0"/>
	<input name="useptc" description="Toggle point based occlusion" storage="uniform" type="float" default="0"/>
	<input name="ptcfile" description="Point cloud filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="coordsys" description="Point cloud coordinate system" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="clamp" description="Clamp excessive occlusion" storage="uniform" type="float" default="0"/>
	<input name="sortbleeding" description="Sort bleeding" storage="uniform" type="float" default="0"/>
	<input name="falloffmode" description="Falloff mode, exponential or polynomial" storage="uniform" type="float" default="0"/>
	<input name="falloff" description="Falloff, 1 = linear" storage="uniform" type="float" default="0"/>
	<output name="Occlusion" description="Occlusion value" storage="varying" type="float" />
	<output name="Envcolor" description="Environment color lookup result" storage="varying" type="color" />
	<output name="Envdirection" description="Average unoccluded direction" storage="varying" type="vector" />
	<output name="Irradiance" description="Irradiance" storage="varying" type="color" />
	<rsl_code>
	
	/* initialize */
	$(Envcolor) = color(0); $(Envdirection) = vector(0); $(Irradiance) = color(0);

	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif /* SHADEOP_ARGUMENTS */
	
	#if RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	"label", $(label), "subset", $(subset), \
								"bias", $(bias), "hitmode", $(hitmode), \
								"coneangle", $(coneangle), "axis", $(axis), \
								"samplebase", $(samplebase), \
								"maxdist", $(maxdist), \
								"environmentmap", $(envmap), \
								"environmentspace", $(envspace), \
								"distribution", $(distribution), \
								"environmentcolor", $(Envcolor), \
								"environmentdir", $(Envdirection), \
								"adaptive", $(adaptive), \
								"minsamples", $(minsamples), \
								"falloffmode", $(falloffmode), \
								"falloff", $(falloff), "pointbased", $(useptc), \
								"filename", $(ptcfile), "hitsides", $(hitsides), \
								"maxsolidangle", $(maxsolidang), \
								"clamp", $(clamp), \
								"sortbleeding", $(sortbleeding), \
								"coordsystem", $(coordsys)
	#elif RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"coordsystem", $(coordsys), \
								"maxdist", $(maxdist), \
								"coneangle", $(coneangle), \
								"samplebase", $(samplebase), \
								"label", $(label), "bias", $(bias), \
								"maxerror", $(maxerror), \
								"pointbased", $(useptc), \
								"environmentmap", $(envmap), \
								"filename", $(ptcfile), \
								"maxpixeldist", $(maxpixeldist), \
								"maxsolidangle", $(maxsolidang), \
								"environmentcolor", $(Envcolor)
	#elif RENDERER == prman
	#define SHADEOP_ARGUMENTS	"adaptive", $(adaptive), \
								"minsamples", $(minsamples), \
								"coordsystem", $(coordsys), \
								"distribution", $(distribution), \
								"maxdist", $(maxdist), \
								"coneangle", $(coneangle), \
								"samplebase", $(samplebase), \
								"hitmode", $(hitmode), \
								"hitsides", $(hitsides), "subset", $(subset), \
								"label", $(label), \
								"environmentmap", $(envmap), \
								"environmentspace", $(envspace), \
								"bias", $(bias), \
								"maxpixeldist", $(maxpixeldist), \
								"maxerror", $(maxerror), \
								"falloffmode", $(falloffmode), \
								"falloff", $(falloff), "pointbased", $(useptc), \
								"filename", $(ptcfile), \
								"maxsolidangle", $(maxsolidang), \
								"clamp", $(clamp), \
								"environmentcolor", $(Envcolor), \
								"environmentdir", $(Envdirection)		
	#elif RENDERER == air
	#define SHADEOP_ARGUMENTS	"bias", $(bias), "label", $(label), \
								"maxdist", $(maxdist), \
								"maxerror", $(maxerror), \
								"maxpixeldist", $(maxpixeldist), \
								"samples", $(samples), "subset", $(subset)
	#elif RENDERER == aqsis
	#define SHADEOP_ARGUMENTS	"blur", $(blur), "bias", $(bias)
	#else /* entropy, bmrt, renderdotc? */
	#endif /* RENDERER */

	/* different order of arguments */
	#if RENDERER == _3delight || RENDERER == pixie || RENDERER == prman
		aov_occlusion += occlusion(	$(P), $(direction), $(samples),
									SHADEOP_ARGUMENTS );
		$(Occlusion) = 1 - aov_occlusion;
	#elif RENDERER == air /* shadow map based, unless map = "raytrace" */
		aov_occlusion += occlusion(	$(occlmap), $(P), $(direction),
									$(angle), SHADEOP_ARGUMENTS );
		$(Occlusion) = 1 - aov_occlusion;
	#elif RENDERER == aqsis /* shadow map based occlusion */
		aov_occlusion += occlusion(	$(occlmap), $(P), $(direction),
									$(samples), SHADEOP_ARGUMENTS );
		$(Occlusion) = 1 - aov_occlusion;
	#else /* entropy, bmrt, renderdotc? */
		$(Occlusion) = 0;		
	#endif /* RENDERER */
	
	</rsl_code>
    <usage>This function returns the ambient occlusion, and optionally environment color, environment direction and indirect lighting. This function&apos;s arguments vary with each renderer&apos;s implementation, so make sure to consult your renderer&apos;s documentation. This block provided the following arguments: &quot;coneangle&quot;, defaults to PI/2; &quot;distribution&quot;, can be &quot;cosine&quot; or &quot;uniform&quot;, defaults to &quot;cosine&quot;. This function can use an optional environment map to use when rays don&apos;t hit the geometry, and can also return the environment direction vector, the average of the unoccluded direction. Note that you can use either the surface normal, or the reflection vector, for the &quot;indir&quot; variable, in which case the function will output ambient occlusion or reflection occlusion respectively. You can also use point-based occlusion, or Aqsis&apos;s implementation which uses multiple shadow maps. Note that this function varies considerably from implementation to implementation, so please consult your renderer&apos;s documentation for details. The occlusion value is passed to aov_occlusion AOV preset, as occlusion, not 1 - occlusion.</usage>
</shrimp>

<shrimp type="function" name="PhotonMap" description="Photon map lookup" author="rconstruct">
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<input name="photonmap" description="Photon map filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="lookuptype" description="Lookup type" storage="uniform" type="string" default="&quot;irradiance&quot;"/>
	<input name="estimator" description="Number of photons" storage="uniform" type="float" default="100"/>
	<input name="mindepth" description="Number of photon bounces" type="float" default="1"/>
	<output name="Ci" description="Output value" type="color"/>
	<rsl_code>
	
	#if RENDERER == _3delight
		$(Ci) = photonmap( $(photonmap), $(P), $(N), "lookuptype", $(lookuptype),
							"estimator", $(estimator), "mindepth", $(mindepth) );
	#elif RENDERER == pixie
		$(Ci) = photonmap( $(photonmap), $(P), $(N), "estimator", $(estimator) );
	#elif RENDERER == aqsis
		$(Ci) = color(0);
	#elif RENDERER == prman
		$(Ci) = photonmap( $(photonmap), $(P), $(N), "lookuptype", "irradiance",
							"estimator", $(estimator) );
	#else /* Air has no photonmap()? */
		$(Ci) = color(0);
	#endif /* RENDERER */

	</rsl_code>
	<usage>This function performs a photon map lookup of a surface point &quot;P&quot; with a surface normal &quot;N&quot;. The lookup type can be &quot;irradiance&quot;, or &quot;radiance&quot;, in which case the lookup is performed before the BRDF calculation, and after the BRDF calculation respectively. The &quot;estimator&quot; specifies the number of photons used, and &quot;mindepth&quot; the depth at which to consider the photons. This varies with renderer implementation, check your renderer documentation for more details.</usage>
</shrimp>

<shrimp name="Trace" type="function" description="Returns light reaching point P from direction R" author="rconstruct">
    <input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="direction" description="Direction" storage="varying" type="vector" default="reflect(I, normalize(N))"/>
    <input name="bias" description="Ray bias" storage="uniform" type="float" default="-1"/>
    <input name="maxdist" description="Maximum distance" storage="uniform" type="float" default="1e38"/>
	<input name="samples" description="Ray samples" type="float" default="1"/>
	<input name="coneangle" description="Cone angle" storage="varying" type="float" default="0"/>
	<input name="blur" description="Amount of blur" type="float" default="0.001"/>
	<input name="label" description="Label associated to the ray" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Set of objects available for ray computations" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Ray hit mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="hitsides" description="Hit sides" storage="uniform" type="string" default="&quot;front&quot;"/>
	<input name="majoraxis" description="Anisotropy axis" type="vector" default="dPdu"/>
	<input name="majorblur" description="Anisotropy blur" type="float" default="0.01"/>
	<input name="weight" description="Weight for importance sampling" type="float" default="1"/>
	<output name="value" description="Trace value" type="float color"/>
	<output name="maxdist" description="Optional ray distance" storage="varying" type="float"/>
	<output name="transmission" description="Option transmission value" storage="varying" type="color"/>
	<output name="alpha" description="Unoccluded fraction of trace" type="float"/>
	<rsl_code>
	
	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif /* SHADEOP_ARGUMENTS */

	/* initialize output */
	$(maxdist) = 0; $(alpha) = 0; $(transmission) = color(0);

	#if RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"bias", $(bias), "samples", \
								$(samples), "samplecone", $(coneangle)			
	#elif RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	$(maxdist), "label", $(label), \
								"subset", $(subset), \
								"bias", $(bias), "hitmode", $(hitmode), \
								"maxdist", $(maxdist), \
								"samplecone", $(coneangle), \
								"samples", $(samples), "transmission", $(transmission)
	#elif RENDERER == prman
	#define SHADEOP_ARGUMENTS	"samplecone", $(coneangle), \
								"bias", $(bias), "label", $(label), \
								"subset", $(subset), "hitmode", $(hitmode), \
								"hitsides", $(hitsides)
	#elif RENDERER == air
	#define SHADEOP_ARGUMENTS	"bias", $(bias), "blur", $(blur), \
								"label", $(label), "maxdist", $(maxdist), \
								"samples", $(samples), "subset", $(subset), \
								"majoraxis", $(majoraxis), \
								"majorblur", $(majorblur), \
								"weight", $(weight), "alpha", $(alpha)
	/* Aqsis has a trace shadeop but returns 0, it can(could?) use */
	/* BMRT's rayserver though. */
	#else
	#define SHADEOP_ARGUMENTS	"bias", $(bias)
	#endif /* RENDERER */
	
	#define $(blockname)_$(value:type)
	#ifdef $(blockname)_float
		$(value) = $(value:type) trace( $(P), $(direction) );
	#else
		$(value) = $(value:type) trace( $(P), $(direction), SHADEOP_ARGUMENTS );
	#endif /* $(blockname)_$(value:type) */
	#undef $(blockname)_$(value:type)

	</rsl_code>
    <usage>Returns the incident light reaching a point &quot;P&quot; from a given direction &quot;R&quot;. If raytracing isn&apos;t supported, trace will return 0. Bias specifies the bias for the ray starting point, and defaults to -1. Maxdist specifies the distance after which no intersections are checked. If the float version is used, then the distance to the nearest ray intersection is returned instead. Note also that the parameters passed are dependent on the &quot;trace&quot; implementation, so check your renderer&apos;s documentation regarding the specifics of the &quot;trace&quot; function, which will surely vary considerably from renderer to renderer.</usage>
</shrimp>

<shrimp name="Transmission" type="function" description="Determines visibility between point 1 and point 2" author="rconstruct">
    <input name="frompoint" description="From point" storage="varying" type="point" default="point &quot;shader&quot; (0,0,0)"/>
	<input name="topoint" description="To point" storage="varying" type="point" default="point &quot;shader&quot; (1,1,1)"/>
	<input name="samples" description="Samples" type="float" default="1"/>
	<input name="minsamples" description="Minimum samples" type="float" default="1"/>
	<input name="samplecone" description="Sample cone" storage="varying" type="float" default="0"/>
	<input name="samplebase" description="Sample base" storage="varying" type="float" default="1"/>
    <input name="bias" description="Ray bias" storage="uniform" type="float" default="-1"/>
	<input name="hitsides" description="Which sides to hit" storage="uniform" type="string" default="&quot;front&quot;"/>
	<input name="hitmode" description="Transmission hit mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="label" description="Labels to associate the rays with" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Set of objects to consider for ray tracing" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e38"/>
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_code>

	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif /* SHADEOP_ARGUMENTS */

	#if RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	"label", $(label), "subset", $(subset), \
								"bias", $(bias), "hitmode", $(hitmode), \
								"samplecone", $(samplecone), \
								"samples", $(samples)
	#elif RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"samples", $(samples), "bias", $(bias), \
								"samplecone", $(samplecone), \
								"sampleBase", $(samplebase), \
								"maxdist", $(maximumdist), "label", $(label)
	#elif RENDERER == prman
	#define SHADEOP_ARGUMENTS	"samples", $(samples), \
								"minsamples", $(minsamples), \
								"samplecone", $(samplecone), \
								"samplebase", $(samplebase), "bias", $(bias), \
								"label", $(label), "subset", $(subset), \
								"hitmode", $(hitmode)
	#else /* no transmission() available */
	#define NOSHADEOP
	#endif /* RENDERER */

	/* Seems only 3delight, prman, and pixie have transmission() shadeop */
	#ifdef NOSHADEOP
		$(Ci) = color(1);
	#else
		$(Ci) = transmission( $(frompoint), $(topoint), SHADEOP_ARGUMENTS );
	#endif /* NOSHADEOP */
	
	#undef SHADEOP_ARGUMENTS
	#undef NOSHADEOP

	</rsl_code>
    <usage>This function returns the color that travels from &quot;pointfrom&quot; to point &quot;pointto&quot;. If this function isn&apos;t implemented, or if raytracing is not available, then the result should be 1. Check your renderer&apos;s documentation, since this function varies considerably with each renderer implementation. Note however that this is typically used to get the amount of transmitted light between &quot;pointfrom&quot; point, to &quot;pointto&quot; point.</usage>
</shrimp>

<shrimp type="function" name="AshikhminShirleyPDF" description="Samples the Ashikhmin-Shirley PDF" author="rconstruct">
	<input name="nu" description="Specular factor on X direction" type="float" default="150"/>
	<input name="nv" description="Specular factor on Y direction" type="float" default="1500"/>
	<input name="samples" description="Number of samples" storage="uniform" type="float" default="32"/>
	<input name="N" description="The surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" type="vector" default="normalize(I)"/>
	<input name="udir" description="Anisotropy direction" type="vector" default="normalize(dPdu)"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Geometry group for ray intersection" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Override for shading mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="0.01"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="envmap" description="Environment map to use with no ray hits" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;camera&quot;"/>
	<input name="filter" description="Environment filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Environment filter width" storage="uniform" type="float" default="1"/>
	<input name="envsamples" description="Environment lookup samples" storage="uniform" type="float" default="4"/>
	<input name="envblur" description="Environment lookup blur" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_sampling.h</rsl_include>
	<rsl_code>
		$(Ci) = samplepdf(	1, $(samples), /* model 1 = Ashikhmin-Shirley */
							$(nu), $(nv),
							0,0,0, /* roughness, exponent, isotropy (unused) */
							$(I), $(udir), $(N),
							$(label), $(subset), $(hitmode), $(bias),
							$(maxdist), $(envmap), $(envspace), $(filter),
							$(width), $(envsamples), $(envblur) );
		aov_reflection += $(Ci);
	</rsl_code>
<usage>This block generates a distribution of rays according to the Ashikhmin-Shirley PDF. The variable &quot;samples&quot; specifies the number of rays to generate, and since this increases the number of loop iterations, increasing the number of rays, increases also the render times (but reduces noise). The &quot;envmap&quot; variable contains the environment map to use when there are no ray intersections. The variables &quot;envspace&quot; controls the space transformation for the ray used for the environment lookup, while &quot;filter&quot;, &quot;envsamples&quot;, &quot;width&quot;, &quot;envblur&quot; control the environment lookup respectively.</usage>
</shrimp>

<shrimp type="function" name="BeckmannPDF" description="Samples the Beckmann PDF" author="rconstruct">
	<input name="roughness" description="Apparent surface roughness" type="float" default="0.2"/>
	<input name="samples" description="Number of samples" storage="uniform" type="float" default="32"/>
	<input name="N" description="The surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" type="vector" default="normalize(I)"/>
	<input name="udir" description="Anisotropy direction" type="vector" default="normalize(dPdu)"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Geometry group for ray intersection" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Override for shading mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="0.01"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="envmap" description="Environment map to use with no ray hits" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;camera&quot;"/>
	<input name="filter" description="Environment filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Environment filter width" storage="uniform" type="float" default="1"/>
	<input name="envsamples" description="Environment lookup samples" storage="uniform" type="float" default="4"/>
	<input name="envblur" description="Environment lookup blur" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_sampling.h</rsl_include>
	<rsl_code>
		// Sample the Beckmann microfacet distribution
		$(Ci) = samplepdf(	4, $(samples),
							0, 0, $(roughness), 0, 0,
							$(I), $(udir), $(N),
							$(label), $(subset), $(hitmode), $(bias),
							$(maxdist), $(envmap), $(envspace), $(filter),
							$(width), $(envsamples), $(envblur) );
		aov_reflection += $(Ci);
	</rsl_code>
<usage>This block generates a distribution of rays according to the Beckmann distribution. The variable &quot;samples&quot; specifies the number of rays to generate, and since this increases the number of loop iterations, increasing the number of rays, increases also the render times (but reduces noise). The &quot;envmap&quot; variable contains the environment map to use when there are no ray intersections. The variables &quot;envspace&quot; controls the space transformation for the ray used for the environment lookup, while &quot;filter&quot;, &quot;envsamples&quot;, &quot;width&quot;, &quot;envblur&quot; control the environment lookup respectively.</usage>
</shrimp>

<shrimp type="function" name="PhongPDF" description="Samples the Ward PDF" author="rconstruct">
	<input name="exponent" description="Phong specular exponent" type="float" default="65"/>
	<input name="samples" description="Number of samples" storage="uniform" type="float" default="32"/>
	<input name="N" description="The surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" type="vector" default="normalize(I)"/>
	<input name="udir" description="Anisotropy direction" type="vector" default="normalize(dPdu)"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Geometry group for ray intersection" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Override for shading mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="0.01"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="envmap" description="Environment map to use with no ray hits" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;camera&quot;"/>
	<input name="filter" description="Environment filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Environment filter width" storage="uniform" type="float" default="1"/>
	<input name="envsamples" description="Environment lookup samples" storage="uniform" type="float" default="4"/>
	<input name="envblur" description="Environment lookup blur" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_sampling.h</rsl_include>
	<rsl_code>
		$(Ci) = samplepdf(	3, $(samples),
							0,0,0, /* nu, nv, roughness (unused) */
							$(exponent), 0, $(I), $(udir), $(N),
							$(label), $(subset), $(hitmode), $(bias),
							$(maxdist), $(envmap), $(envspace), $(filter),
							$(width), $(envsamples), $(envblur) );
		aov_reflection += $(Ci);
	</rsl_code>
<usage>This block generates a distribution of rays according to the Phong PDF. The variable &quot;samples&quot; specifies the number of rays to generate, and since this increases the number of loop iterations, increasing the number of rays, increases also the render times (but reduces noise). The &quot;envmap&quot; variable contains the environment map to use when there are no ray intersections. The variables &quot;envspace&quot; controls the space transformation for the ray used for the environment lookup, while &quot;filter&quot;, &quot;envsamples&quot;, &quot;width&quot;, &quot;envblur&quot; control the environment lookup respectively.</usage>
</shrimp>

<shrimp type="function" name="SchlickPDF" description="Samples the Ward PDF" author="rconstruct">
	<input name="roughness" description="Apparent surface roughness" type="float" default="0.1"/>
	<input name="isotropy" description="Surface isotropy" type="float" default="0.03"/>
	<input name="samples" description="Number of samples" storage="uniform" type="float" default="32"/>
	<input name="N" description="The surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" type="vector" default="normalize(I)"/>
	<input name="udir" description="Anisotropy direction" type="vector" default="normalize(dPdu)"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Geometry group for ray intersection" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Override for shading mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="0.01"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e+38"/>
		<input name="envmap" description="Environment map to use with no ray hits" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;camera&quot;"/>
	<input name="filter" description="Environment filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Environment filter width" storage="uniform" type="float" default="1"/>
	<input name="envsamples" description="Environment lookup samples" storage="uniform" type="float" default="4"/>
	<input name="envblur" description="Environment lookup blur" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_sampling.h</rsl_include>
	<rsl_code>
		$(Ci) = samplepdf(	2, $(samples), /* model 2 = Schlick PDF */
							0, 0, $(roughness), 0, $(isotropy),
							$(I), $(udir), $(N),
							$(label), $(subset), $(hitmode), $(bias),
							$(maxdist), $(envmap), $(envspace), $(filter),
							$(width), $(envsamples), $(envblur) );
		aov_reflection += $(Ci);
	</rsl_code>
<usage>This block generates a distribution of rays according to the Schlick PDF. The variable &quot;samples&quot; specifies the number of rays to generate, and since this increases the number of loop iterations, increasing the number of rays, increases also the render times (but reduces noise). The &quot;envmap&quot; variable contains the environment map to use when there are no ray intersections. The variables &quot;envspace&quot; controls the space transformation for the ray used for the environment lookup, while &quot;filter&quot;, &quot;envsamples&quot;, &quot;width&quot;, &quot;envblur&quot; control the environment lookup respectively.</usage>
</shrimp>

<shrimp type="function" name="WardPDF" description="Samples the Ward PDF" author="rconstruct">
	<input name="ax" description="Roughness on X direction" type="float" default="0.3"/>
	<input name="ay" description="Roughness on Y direction" type="float" default="0.03"/>
	<input name="samples" description="Number of samples" storage="uniform" type="float" default="32"/>
	<input name="N" description="The surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" type="vector" default="normalize(I)"/>
	<input name="udir" description="Anisotropy direction" type="vector" default="normalize(dPdu)"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Geometry group for ray intersection" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="hitmode" description="Override for shading mode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="0.01"/>
	<input name="maxdist" description="Maximum ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="envmap" description="Environment map to use with no ray hits" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment space" storage="uniform" type="string" default="&quot;camera&quot;"/>
	<input name="filter" description="Environment filter" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Environment filter width" storage="uniform" type="float" default="1"/>
	<input name="envsamples" description="Environment lookup samples" storage="uniform" type="float" default="4"/>
	<input name="envblur" description="Environment lookup blur" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_sampling.h</rsl_include>
	<rsl_code>
		// This block deals with both isotropic and anisotropic Ward PDF
		// according to values of ax/ay (nu/nv)
		$(Ci) = samplepdf(	0, $(samples), $(ax), $(ay),
							0,0,0, /* unused roughness/exponent/isotropy*/
							$(I), $(udir), $(N),
							$(label), $(subset), $(hitmode), $(bias),
							$(maxdist), $(envmap), $(envspace), $(filter),
							$(width), $(envsamples), $(envblur) );
		aov_reflection += $(Ci);
	</rsl_code>
<usage>This block generates a distribution of rays according to the Ward PDF. If the values of &quot;ax&quot; and &quot;ay&quot; (the apparent surface roughness along the X and Y directions respectively) are identical, then isotropic Ward distribution is used, otherwise, the anisotropic Ward distribution is used instead. The variable &quot;samples&quot; specifies the number of rays to generate, and since this increases the number of loop iterations, increasing the number of rays, increases also the render times (but reduces noise). The &quot;envmap&quot; variable contains the environment map to use when there are no ray intersections.The variables &quot;envspace&quot; controls the space transformation for the ray used for the environment lookup, while &quot;filter&quot;, &quot;envsamples&quot;, &quot;width&quot;, &quot;envblur&quot; control the environment lookup respectively.</usage>
</shrimp>

<shrimp name="Ambient" type="function" description="Ambient term." author="rconstruct">
    <input name="Ka" description="Ambient light coefficient" type="float" default="0.1"/>
	<input name="Camb" description="Ambient color" type="color" default="color(.2)"/>
	<output name="Ci" description="Shaded color" type="color"  />
	<rsl_code>
		aov_surfacecolor += $(Camb);
		aov_ambient += $(Ka) * ambient();
		$(Ci) = aov_surfacecolor * aov_ambient;
	</rsl_code>
    <usage>Ambient term. The surface color value is passed to &quot;aov_surfacecolor&quot;, and ambient value, to the &quot;aov_ambient&quot; AOV presets.</usage>
</shrimp>

<shrimp name="AshikhminShirley" type="function" description="Ashikhmin-Shirley shading model." author="rconstruct" rolled="1">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.3)"/>
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
	<input name="Crefl" description="Reflection color" type="color" default="color(1)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.5"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.5"/>
	<input name="Kr" description="Reflection coefficient" type="float" default="0.5"/>
	<input name="ior" description="Index of Refraction" type="float" default="2.0"/>
    <input name="nu" description="Specularity along U direction" type="float" default="1000"/>
    <input name="nv" description="Specularity along V direction" type="float" default="10"/>
	<input name="samples" description="Environment samples" storage="uniform" type="float" default="0"/>
    <input name="envmap" description="Environment map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="envspace" description="Environment coordinate system" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="N" description="Surface normal" storage="varying" type="normal vector" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="direction" description="Direction vector" storage="varying" type="vector" default="normalize(dPdu)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
	
	#define $(blockname)_$(samples)
	
	aov_surfacecolor += $(Cdiff);
	aov_specularcolor += $(Cspec);
		
		$(Ci) = LocIllumAshShir(	$(N), $(I), $(direction), $(Cdiff),
									$(Cspec), $(Kd), $(Ks), $(nu), $(nv),
									$(category),
									DECLARE_AOV_PARAMETERS );
	#ifdef $(blockname)_0
		$(Ci) = $(Ci);
	#else /* add environment sampling */
		aov_reflection += $(Crefl) * EnvIllumAshShir(
								faceforward( $(N), $(I) ), -$(I),
								$(direction), $(Kd), $(Ks), $(nu), $(nv),
								$(samples), $(envmap), $(envspace) );
		$(Ci) += aov_reflection;
	#endif /* $(blockname)_$(samples) */
	#undef $(blockname)_$(samples)
	
	</rsl_code>
	<usage>Based on Peter Stuart&apos;s implementation of the Ashikhmin-Shirley shading model. Samples the environment according to the number of ray samples. Notice that the more samples you use, the longer it takes to render. The parameters &quot;nu&quot; and &quot;nv&quot; control the specularity of the anisotropy direction along X, and Y respectively, being the parameter &quot;direction&quot;, the anisotropy direction, which defaults to &quot;dPdu&quot;. The variable &quot;samples&quot; controls the environment sampling, any value higher than 0 turning environment reflections on, which can either be an environment map as defined in &quot;envmap&quot;, or raytraced reflections if &quot;envmap&quot; is empty: the default is no environment map and 0 samples, so no reflections are considered for the resulting color. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_diffuse&quot;, &quot;aov_specularcolor&quot;, &quot;aov_specular&quot;, and &quot;aov_reflection&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Banks" type="function" description="Banks anisotropic model" author="rconstruct">
	<input name="Cdiff" description="Surface color" type="color" default="color(0.5)"/>
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
	<input name="Ka" description="Ambient light coefficient" type="float" default="0.1"/>
	<input name="Kd" description="Diffuse light coefficient" type="float" default="0.5"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1"/>
    <input name="roughness" description="Surface roughness" type="float" default="0.25"/>
	<input name="direction" description="Anisotropy direction" storage="varying" type="vector" default="dPdu"/>
    <input name="N" description="Normal vector" storage="varying" type="normal" default="normalize(N)"/>
    <input name="I" description="Eye vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_specularcolor += $(Cspec);
		aov_ambient += $(Ka) * ambient();

		$(Ci) = aov_surfacecolor * aov_ambient + banksaniso(
				$(Cdiff), $(Cspec), $(Kd), $(Ks), $(roughness), $(N),
				$(I), $(direction), $(category),
				DECLARE_AOV_PARAMETERS ) ;
	</rsl_code>
    <usage>Implementation of the Banks fast anisotropic model, based on the paper &quot;Illumination in Diverse Codimensions&quot;, by David C. Banks. The anisotropy direction is specified via the &quot;direction&quot; parameter, defaulting to &quot;dPdu&quot;, while the parameter &quot;roughness&quot; controls the apparent surface roughness.  This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot;, &quot;aov_specularcolor&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Fur" type="function" description="Clint Hanson and Armin Bruderlin&apos;s SIG2k Fur shader" author="rconstruct" rolled="1">
    <input name="Ka" description="Ambient light coefficient" type="float" default="0.0287"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.77"/>
    <input name="Ks" description="Global specular intensity" type="float" default="1"/>
    <input name="roughness1" description="Primary specular roughness" type="float" default="0.008"/>
	<input name="roughness2" description="Secondary specular roughness" type="float" default="0.016"/>
	<input name="Ks1" description="Primary highlights intensity" type="float" default="0.3"/>
	<input name="Ks2" description="Secondary highlights intensity" type="float" default="0.7"/>
	<input name="startspec" description="Specularity start" type="float" default="0.3"/>
	<input name="endspec" description="Specularity end" type="float" default="0.95"/>
	<input name="specsizefade" description="Specular size fade" type="float" default="0.1"/>
	<input name="coneangle" description="Illumination cone angle" type="float" default="180"/>
	<input name="fadestart" description="Fade start" type="float" default="0.005"/>
	<input name="fadeend" description="Fade end" type="float" default="0.001"/>
	<input name="darkening" description="Clump darkening strength"  type="float" default="0"/>
	<input name="rootcolor" description="Root color" type="color" default="color(.9714, .9714, .9714)"/>
	<input name="tipcolor" description="Tip color" type="color" default="color( .519, .325, .125 )"/>
	<input name="specularcolor" description="Specular color" type="color" default="color( .7595, .6625, .5625 )"/>
	<input name="surfacecolor" description="Static ambient color" type="color" default="color( .057, .057, .057 )"/>
	<input name="haircolvar" description="RIB hair color variable" storage="uniform" type="float" default="0"/>
	<input name="hairlength" description="RIB hair length" storage="uniform" type="float" default="0"/>
	<input name="hairid" description="RIB hair id" storage="uniform" type="float" default="0"/>
	<input name="ribnormal" description="RIB surface normal" storage="uniform" type="normal" default="normal(1)"/>
	<input name="ribclump" description="RIB clump vector" storage="varying" type="vector" default="vector(0)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		$(Ci) = SIG2k_srf_fur( $(Ka), $(Kd), $(Ks), $(roughness1),
				$(roughness2), $(Ks1), $(Ks2), $(startspec), $(endspec),
				$(specsizefade), $(coneangle), $(fadestart),
				$(fadeend), $(darkening), $(rootcolor), $(tipcolor),
				$(specularcolor), $(surfacecolor), $(haircolvar), $(hairlength),
				$(hairid), $(ribnormal), $(ribclump), $(category),
				DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Clint Hanson and Armin Bruderlin&apos;s fur shader, presented at Siggraph2000, from The RenderMan Repository - check the link . Note that specular color should be (1+tipcolor)/2. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot;, &quot;aov_specularcolor&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.
	<rsl_link>http://www.renderman.org</rsl_link></usage>
</shrimp>

<shrimp name="GranierHeidrich" type="function" description="Granier-Heidrich Thin-film interference BRDF" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.7"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.9"/>
    <input name="ior" description="IOR for RGB components" type="vector" default="vector(1.4, 1.7, 2.0)"/>
    <input name="densitymin" description="density range minimum" type="float" default="65"/>
    <input name="densitymax" description="density range maximum" type="float" default="67"/>
    <input name="specmin" description="specmin" type="float" default="70"/>
    <input name="specmax" description="specmax" type="float" default="230"/>
    <input name="freqmin" description="frequency minimum" type="float" default="60"/>
    <input name="freqmax" description="frequency maximum" type="float" default="70"/>
    <input name="deviation" description="deviation" type="float" default="0.2"/>
    <input name="seed" description="noise seed" type="float" default="1234"/>
	<input name="s" description="noise X coordinates" storage="varying" type="float" default="s"/>
	<input name="t" description="noise Y coordinates" storage="varying" type="float" default="t"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_include>rsl_shrimp_helpers.h</rsl_include>
	<rsl_include>rsl_shrimp_fractal.h</rsl_include>
	<rsl_code>

        normal $(blockname)_Nf = faceforward( $(N) , $(I) );
        vector $(blockname)_Vf = -$(I);

		float $(blockname)_drange[2] = { $(densitymin), $(densitymax) };
		float $(blockname)_iorrgb[3] = {	xcomp( $(ior) ),
											ycomp( $(ior) ),
											zcomp( $(ior) ) };
		float $(blockname)_spec[2] = { $(specmin), $(specmax) };
		float $(blockname)_freq[2] = { $(freqmin), $(freqmax) };

		float $(blockname)_lambda[3] = { 645, 525, 445 }; /* wavelenght */
		
		float $(blockname)_d = blend( $(blockname)_drange[0],
						$(blockname)_drange[1], noise( $(s)
						* $(blockname)_freq[0] + $(seed) + 1998122 ));

		normal $(blockname)_Nl = normalize( normal( $(blockname)_Nf
						+ $(deviation) * snoise2( $(s) * $(blockname)_freq[1]
						+ $(seed) + 19928, $(t) * $(blockname)_freq[1]
						/ 2 + $(seed) + 1998122 )));

		aov_surfacecolor += $(Cdiff);

		$(Ci) = LocIllumGranier( $(blockname)_Nf, $(blockname)_Nl,
							$(blockname)_Vf, $(blockname)_spec[0],
							$(blockname)_spec[1], $(blockname)_d,
							$(blockname)_iorrgb, $(blockname)_lambda,
							$(Cdiff), $(Kd), $(Ks), $(category),
							DECLARE_AOV_PARAMETERS );

	</rsl_code>
    <usage>Peter Stuart&apos;s implementation of the Granier-Heidrich thin-film interference BRDF, as described in &quot;A Simple Layered RGB BRDF Model&quot;, by Xavier Granier and Wolfgang Heidrich. The parameter &quot;densitymin&quot; and &quot;densitymax&quot; control both the minimum and maximum substrate thickness respectivly, with &quot;ior&quot;, the index of refraction for the R, G, and B wavelengths encoded in a vector. The parameter &quot;specmin&quot; and &quot;specmax&quot; control the minimum and maximum specular exponent of the rays reflected on the substrate, with &quot;freqmin&quot; and &quot;freqmax&quot; as the minimum and maximum frequency of the perlin noise, and &quot;deviation&quot;, the deviation of the normals in the range [0,1]. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_diffuse&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="HanrahanKrueger" type="function" description="Matt Pharr&apos;s implementation of Hanrahan-Krueger model" author="rconstruct">
	<input name="Cs" description="Surface color" type="color" default="color( .8, .5, .5 )"/>
    <input name="sheencolor" description="Sheen color" type="color" default="1.0"/>
	<input name="Ka" description="Ambient coefficient" type="float" default=".1"/>
    <input name="ior" description="Index of refraction" type="float" default="1.4"/>
    <input name="thickness" description="Thickness" type="float" default="0.5"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cs);
		aov_ambient += $(Ka) * ambient();
		aov_scattering += subsurfaceSkin( $(I), $(N), $(Cs), $(sheencolor),
								1/$(ior), $(thickness), $(category) );
        $(Ci) = aov_surfacecolor * aov_ambient + aov_scattering;
	</rsl_code>
	<usage>Based on Matt Pharr&apos;s skin shader, a surface shader that implements a shading model that should have a visual appearance generally similar to that of skin. Based on phenomenological information about skin reflectance from Pat Hanrahan and Wolfgang Krueger&apos;s &quot;Reflection from layered surfaces due to subsurface scattering&quot;, proceedings of SIGGRAPH 1993. The parameters are the skin base color, the oily surface sheen color, the ratio of the indices of refraction of incoming ray to transmitted ray, and the skin layer thickness. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot; and &quot;aov_scattering&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="KajiyaKay" type="function" description="Hair shader, Kajiya-Kay model, based on Mario Marengo&apos;s VEX work." author="rconstruct">
    <input name="Ka" description="Ambient light coefficient" type="float" default="0.1"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1.0"/>
    <input name="roughness" description="Specular roughness" type="float" default="0.01"/>
    <input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="surfacecolor" description="Surface color" type="color" default="color(1)"/>
	<input name="rootcolor" description="Hair base color" type="color" default="color( .2, .15, .1)"/>
	<input name="tipcolor" description="Hair tip color" type="color" default="color( .84, .75, .4)"/>
    <input name="specularcolor" description="Specular color" type="color" default="color(1, 1, .8)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = kajiyakay( $(Ka), $(Kd), $(Ks), $(roughness), $(surfacecolor),
				$(rootcolor), $(tipcolor), $(specularcolor), $(N), $(I),
				$(category),
				DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Hair shader, based on Mario Marengo&apos;s VEX work for an implementation of Kajiya-Kay hair illumination model. &quot;Ka&quot;, &quot;Kd&quot;, &quot;Ks&quot; have the usual meaning, &quot;roughness&quot; is the specular roughness. &quot;Cs&quot; and &quot;Os&quot; the usual meaning, surface color and opacity.  This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="KubelkaMunk" type="function" description="Kubelka-Munk model for the composition of layered surfaces." author="rconstruct">
    <input name="Kd" description="Diffuse light coefficient" type="color" default="0.05"/>
    <input name="Ks" description="Specular light coefficient" type="color" default="0.3"/>
	<input name="thicklayer" description="Reflectivity value of infinitely thick layer" type="color" default="color( .9, .5, .2 )"/>
    <input name="thickness" description="Layer thickness" type="float" default="0.5"/>
    <input name="roughness" description="Surface roughness" type="float" default="0.25"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = KMOverGlossy(	$(N), $(I), $(Kd), $(Ks), $(thicklayer), 
								$(thickness), $(roughness),
								DECLARE_AOV_PARAMETERS );
	</rsl_code>
<usage>Based on Matt Pharr&apos;s implementation of the Kubelka-Munk model, for the composition of layered surfaces. &quot;SigmaA&quot; is the attenuation coefficient of the paint layer, describing the differential attenuation per distance travelled in the medium, while &quot;SigmaS&quot; represents the scattering coefficient of the paint layer - as light travels in the medium, it&apos;s scattered to different directions, some of this scattered light eventually exits the medium, with the color of the particles it interacted with. Both &quot;SigmaA&quot; and &quot;SigmaS&quot; are estimated according to the reflectance value of an infinitely thick layer, set with the parameter &quot;thicklayer&quot;. See SIGGRAPH 2001 course notes, &quot;Advanced RenderMan 3: Render Harder&quot;, for notes and background information. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_diffuse&quot;, &quot;aov_specularcolor&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Lafortune" type="function" description="Lafortune BRDF" author="rconstruct">
    <input name="Ka" description="Ambient light coefficient" type="float" default="0.05"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.2"/>
    <input name="Ks" description="Specular coefficient" type="float" default="1"/>
	<input name="p" description="Correction for each lobe" type="vector" default="vector(0)"/>
    <input name="model" description="Lobe data, range [0,28]" storage="uniform" type="float" default="21"/>
    <input name="colormatrix" description="Color matrix metal/skin, range [1,2]" storage="uniform" type="float" default="0"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
    <input name="direction" description="Surface direction tangent" storage="varying" type="vector" default="dPdu"/>
    <input name="Cs" description="Surface color" type="color" default="color(.3094, .39667, .70837)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = lafortunersl(	$(Ka), $(Kd), $(Ks), $(p),
								$(Cs), clamp( $(model), 0, 28),
								$(colormatrix), $(N), $(I),
								$(direction), $(category),
								DECLARE_AOV_PARAMETERS );
	</rsl_code>
	<usage>Based on Stephen H. Westin&apos;s implementation of the Lafortune model, on Ryan Heniser&apos;s DSO version, and extended to use the &quot;pump-up&quot; factor suggested by Attila Neumann in his dissertation:&quot;Constructions of Bidirectional Reflectance Distribution Functions&quot;, as well as with coefficient data from Ryan Heniser&apos;s DSO version, the paper &quot;Stochastic Local Search for BRDF Parameterization&quot; by Jonathan Backer, Fred Kimberley, Iryna Skrypnyk, &quot;A Comparison of Four BRDF Models&quot; by Stephen H.Westin, Hongsong Li, Kenneth E.Torrance, and Tek2Shoot&apos;s T2SFilePack for Tek2Shoot&apos;s implementation of the Lafortune model for SoftimageXSI and T2SMaterial shader. The variable &quot;model&quot; controls which material coefficients to use, and is on the [0,28] range - please see the data header for more information on these materials&apos;s coefficients. The variable &quot;p&quot; is a vector for the Neumann &quot;pump-up&quot; factor, in which the first element is the exponent correction for the first lobe, the second element the exponent correction for the second lobe, and the third element, the exponent correction for the third lobe. Note that when &quot;p&quot; is 0, the result is the original Lafortune model. The variable &quot;colormatrix&quot; is a toggle switch, 0 or 1 - when enabled, the resulting color is multiplied with a supplied color matrix to perform color correction from the camera&apos;s space. Defaults to disabled, but should be enabled for some material data, please see the original paper: &quot;Non-Linear Approximaation of Reflectance Functions&quot;, by Eric P.F.Lafortune, Sing-Choong Foo, Kenneth E.Torrance, and Donald P.Greenberg for more informations, as well as the Cornell&apos;s University Program of Computer Graphics website dedicated to this topic and measurements check the link . This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot; and &quot;aov-specular&quot; AOV presets. It'll be extended later to allow full user specification of lobes via material blocks.
		<rsl_link>http://www.graphics.cornell.edu/online/measurements/reflectance/index.html</rsl_link>
	</usage>
	</shrimp>

<shrimp name="MKGooch" type="function" description="Gooch Non-PhotoRealistic shader" author="rconstruct">
	<input name="Ka" description="Ambient light coefficient" type="float" default="0.1"/>
	<input name="Kd" description="Diffuse light coefficient" type="float" default=".5"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.5"/>
    <input name="alpha" description="Gooch cool color factor" type="float" default="0.25"/>
	<input name="beta" description="Gooch warm color factor" type="float" default="0.5"/>
	<input name="B" description="Used to construct the cool color" type="float" default="0.55"/>
	<input name="Y" description="Used to contruct the warm color" type="float" default="0.3"/>
	<input name="roughness" description="Specular roughness" type="float" default=".1"/>
	<input name="Cdiff" description="Surface color" type="color" default="color(.2)"/>
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = MKgooch(	$(N), $(I), $(Ka), $(Kd), $(Ks), $(alpha),
							$(beta), $(roughness), $(B), $(Y),
							$(Cdiff), $(Cspec), $(category),
							DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Gooch non photorealistic shading model, by Mike King, as described in an &quot;A Non-Photorealistic Lighting Model for Automatic Technical Illustration&quot;, in the Siggraph 1998 proceedings. &quot;Ka&quot;, &quot;Kd&quot;, &quot;Ks&quot;, are the ambient, diffuse, and specular coefficients respectively, with &quot;alpha&quot; and &quot;beta&quot;, the Gooch cool and warm color factors. &quot;B&quot; and &quot;Y&quot; are used to contruct the cool and warm color, and &quot;roughness&quot; and &quot;Cspec&quot;, to control the apparent specular roughness and specular color respectively. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot;, &quot;aov_specularcolor&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="RTGlass" type="function" description="Raytraced glass, with attenuation" author="rconstruct" rolled="1">
	<input name="Ka" description="Ambient light coefficient" type="float" default="0.01"/>
	<input name="Kd" description="Diffuse light coefficient" type="float" default="0.05"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.95"/>
	<input name="Kr" description="Reflection coefficient" type="float" default="0.95"/>
	<input name="Kt" description="Refraction coefficient" type="float" default="0.98"/>
	<input name="ior" description="Refraction index" type="float" default="1.54"/>
	<input name="roughness" description="Specular roughness" type="float" default="0.2"/>
	<input name="sharpness" description="Specular sharpness" type="float" default="0.7"/>
	<input name="attencolor" description="Attenuation color" type="color" default="color( .1, .3, .8)"/>
	<input name="krblur" description="Reflection blur" type="float" default="0"/>
	<input name="ktblur" description="Refraction blur" type="float" default="0"/>
	<input name="aexp" description="Attenuation exponent" type="float" default="2"/>
	<input name="aamp" description="Attenuation scale" type="float" default="0.1"/>
	<input name="samples" description="Ray samples" storage="uniform" type="float" default="1"/>
	<input name="rmaxdist" description="Maximum reflection ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="tmaxdist" description="Maximum refraction ray distance" storage="uniform" type="float" default="1e+38"/>
	<input name="bias" description="Raytracing bias" storage="uniform" type="float" default="0.001"/>
	<input name="spectype" description="Specular type, glossy or standard specular" storage="uniform" type="string" default="&quot;glossy&quot;"/>
	<input name="rbounces" description="Maximum number of reflection bounces" storage="uniform" type="float" default="3"/>
	<input name="usespec6" description="Toggle between RGB or spec6(RYGCBV) model" storage="uniform" type="float" default="0" />
	<input name="optics" description="Optics model for spec6, range [0,112]" storage="uniform" type="float" default="50" />
	<input name="envmap" description="Environment map, raytracing" storage="uniform" type="string" default="&quot;raytrace&quot;"/>
    <input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" storage="varying" type="color"/>
	<output name="Oi" description="Shaded opacity" storage="varying" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		$(Ci) = color(0);
		$(Oi) = color(0);
		
#if RENDERER == pixie // problems with RYGCBV dispersion (see header)
        rtglass(	$(Ka), $(Kd), $(Ks), $(Kr), $(Kt), $(ior),
					$(roughness), $(sharpness), $(attencolor),
					$(krblur), $(ktblur), $(aexp), $(aamp), $(samples),
					$(rmaxdist), $(tmaxdist), $(bias), $(spectype),
					$(rbounces), 0, 0, $(I), $(N), $(envmap), $(Ci), $(Oi),
					$(category),
					DECLARE_AOV_PARAMETERS );
#else	
        rtglass(	$(Ka), $(Kd), $(Ks), $(Kr), $(Kt), $(ior),
					$(roughness), $(sharpness), $(attencolor),
					$(krblur), $(ktblur), $(aexp), $(aamp), $(samples),
					$(rmaxdist), $(tmaxdist), $(bias), $(spectype),
					$(rbounces), $(optics), $(usespec6), $(I), $(N),
					$(envmap), $(Ci), $(Oi), $(category),
					DECLARE_AOV_PARAMETERS );
#endif // Pixie&apos;s problems with spec6 dispersion

	</rsl_code>
	<usage>Raytraced glass shader, based on Larry Gritz&apos;s glass shader, Mario Marengo&apos;s VEX work and discussion at odforce.net, and Alan Warren&apos;s port of Mario Marengo&apos;s VEX shader. Refraction and reflection blur defaults to 0, ray samples default to 1, so you can increase samples to get better antialiasing, or when blur is used. Attenuation is controlled by &quot;aexp&quot; and &quot;aamp&quot; variables, the attenuation exponent and scale respectively, while &quot;attencolor&quot; is the attenuation color. Spectype defaults to &quot;glossy&quot; (Larry Gritz&apos;s glossy specular model), any other value will get you specular highlights using the standard &quot;specular&quot; function. Maximum ray distance defaults to 1e+38, set this to a lower value, otherwise you'll be raytracing everything + the kitchen sink (it might be a good idea to use trace sets as well). Note that you need to set your RIB raytracing options and attributes, and make sure the geometry is correctly oriented. This block passes the resulting values to the aov_ambient, aov_diffuse, aov_specular, aov_reflection and aov_refraction AOV presets. The &quot;usespec6&quot; variable toggles between normal RGB model (1 sample), or spec6/RYGCVC model (6 samples), in which case, the index of refraction for the 6 wavelenghts is determined by the glass model chosen in &quot;optics&quot;, the valid range being [0,112]. Note, that this is at the moment, very expensive to render. Note that Aqsis doesn&apos;s supports raytracing yet, and this wasn&apos;t tested with BMRT&apos;s rayserver, so you&apos;re on your own. Also note that there were problems with Pixie and dispersion in RYGCBV, so dispersion is bypassed for Pixie, for the time being until a solution is found. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="SHWVelvet" type="function" description="Stephen H. Westins velvet shader." author="rconstruct">
    <input name="Ks" description="Specular light coefficient" type="float" default="0.8"/>
    <input name="backscatter" description="Back scattering value" type="float" default="0.6"/>
    <input name="edginess" description="Backscattering edginess" type="float" default="10"/>
    <input name="roughness" description="Roughness" type="float" default="0.05"/>
    <input name="sheen" description="Sheen color" type="color" default="color(.5, .4, .2)"/>
    <input name="N" description="Normal vector" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Eye vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_include>rsl_shrimp_helpers.h</rsl_include>
	<rsl_code>
        $(Ci) = velvet( $(Ks), $(backscatter), $(edginess), $(roughness),
						$(sheen), $(N), $(I), $(category),
						DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Based on Stephen H. Westin&apos;s velvet shader. &quot;Ks&quot; controls overall intensity of effect, &quot;edginess&quot; controls the edge sharpness of the backscattering effect, &quot;roughness&quot; controls the apparent surface roughness, and &quot;sheen&quot; controls the sheen color. This block passes the resulting values to the &quot;aov_rimlighting&quot; and &quot;aov_scattering&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="SHWWood" type="function" description="Stephen H. Westins wood shader." author="rconstruct">
    <input name="Ka" description="Ambient coefficient" type="float" default="0.1"/>
    <input name="Kd" description="Diffuse coefficient" type="float" default="0.8"/>
    <input name="Ks" description="Specular highlight fudge" type="float" default="1.0"/>
    <input name="ior" description="Index of refraction" type="float" default="1.5"/>
    <input name="width" description="Specular width" type="float" default="0.1745"/>
    <input name="roughness" description="Specular roughness" type="float" default="0.2"/>
    <input name="fiberAxis" description="Fiber axis" type="vector" default="vector( 1, 0, 0)"/>
    <input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
    <input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="surfacecolor" description="Diffuse color" type="color" default="color( .45, .3, .12)"/>
    <input name="fibercolor" description="Fiber color" type="color" default="color(1, .6, .4)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = woodreflectance(	$(ior), $(width), $(roughness),
									$(Ka), $(Kd), $(Ks),
									$(fiberAxis), $(I), $(N),
									$(surfacecolor), $(fibercolor),
									$(category),
									DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Based on Stephen H. Westin&apos;s wood shader, from &quot;Measuring and Modeling the Appearance of Finished Wood&quot;, SIGGRAPH2005, by Stephen R. Marschner, Stephen H. Westin, Adam Arbree, and Jonathan T. Moon. &quot;Ka&quot;, &quot;Kd&quot;, are the ambient and diffuse coefficients, and &quot;Ks&quot; is a fudge factor for the surface highlight. &quot;FiberAxis&quot;, controls the local fiber orientation in local coordinates; &quot;width&quot; controls the width of the specular highlight, in radians; &quot;Cfiber&quot; controls the anisotropic highlight color, &quot;Cdiff&quot; controls the surface color; &quot;ior&quot; controls the index of refraction, &quot;roughness&quot; controls the specular roughness. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Strauss" type="function" description="Strauss empirical BRDF" author="rconstruct">
	<input name="Cdiff" description="Surface color" type="color" default="color(.5)"/>
	<input name="smoothness" description="Surface smoothness" type="float" default=".5"/>
	<input name="metalness" description="Surface metalness" type="float" default=".5"/>
	<input name="transparency" description="Surface transparency" type="float" default="0"/>
    <input name="N" description="Normal vector" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Eye vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		$(Ci) = strauss(	$(Cdiff), $(smoothness), $(metalness),
							$(transparency),
							$(N), $(I), $(category),
							DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Implementation of the Strauss empirical BRDF, from the paper: &quot;A Realistic Lighting Model for Computer Animators&quot;, by Paul S.Strauss. All parameters are in the range [0,1]. The &quot;smoothness&quot; parameter controls the surface smoothness, being 0 a rough, and perfectly diffuse surface, and 1 a smooth and perfectly specular mirroring surface - it affects both the diffuse to specular reflection ratio, and also the size and brightness of the specular highlights. The &quot;metalness&quot; parameter controls the off-specular peaks of the surface, being 0 the appearance of a non-metal surface, and 1 the appearance of a metal surface - this affects the specular color, as well as the amount of diffuse contribution. The &quot;transparency&quot; parameter indicates that the surface is not totally opaque. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_diffuse&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="ThinFilm" description="Thin film interference" author="rconstruct">
	<input name="Ko" description="Opacity factor" type="float" default="1"/>
	<input name="depth" description="Surface depth in nanometers" type="float" default="1896" />
	<input name="I" description="Viewer vector" type="vector" default="normalize(I)" />
	<input name="N" description="Surface normal" type="normal" default="normalize(N)" />
	<input name="iorryg" description="IOR for RYG wavelengths" storage="uniform" type="vector" default="vector(1.2, 1.3, 1.4)"/>
	<input name="iorcbv" description="IOR for CBV wavelengths" storage="uniform" type="vector" default="vector(1.5, 1.6, 1.7)"/>
	<input name="Cs" description="Base surface color" type="color" default="color(.3, .6, .9)" />
	<output name="Ci" description="Surface color" storage="varying" type="color" />
	<output name="Oi" description="Surface opacity" storage="varying" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		$(Ci) = color(0);
		$(Oi) = color(1);
		// build RYGCBV IORs from RYG, CBV vectors
		uniform float $(blockname)_ior[6] = {
			xcomp($(iorryg)), ycomp($(iorryg)), zcomp($(iorryg)),
			xcomp($(iorcbv)), ycomp($(iorcbv)), zcomp($(iorcbv)) };

		thinfilm(	$(depth), $(I), $(N), $(blockname)_ior, $(Cs),
					$(Ci), $(Oi), DECLARE_AOV_PARAMETERS );
		
		$(Oi) *= $(Ko);
		aov_surfacecolor += $(Ci);
		aov_opacity += $(Oi);
		$(Ci) *= $(Oi);
	</rsl_code>
	<usage>Thin film interference block, based on Jens&apos;s VEX shader. The variable &quot;depth&quot; controls the thickness of the coating, measured in nanometers; &quot;Ko&quot; the intensity of the opacity factor; &quot;Cs&quot; controls the base surface color, and &quot;iorryg&quot; and &quot;iorcbv&quot; are two vectors that contain the index of refractions for the R, Y, G, and for the C, B, V wavelengths.</usage>
</shrimp>

<shrimp name="TSHair" type="function" description="Hair shader, based on Thorsten Scheuermann&apos;s work for Ati&apos;s 3d application research group." author="rconstruct">
    <input name="Ka" description="Ambient light coefficient" type="float" default="0.05"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.4"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1.0"/>
    <input name="shift1" description="Primary specular shift" type="float" default="0.1"/>
    <input name="shift2" description="Secondary specular shift" type="float" default="0.25"/>
    <input name="exponent1" description="Primary specular exponent" type="float" default="15"/>
    <input name="exponent2" description="Secondary specular exponent" type="float" default="25"/>
    <input name="specmask" description="Specular mask" type="float" default="0.5"/>
    <input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
    <input name="I" description="Viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="surfacecolor" description="Surface color" type="color" default="Cs"/>
	<input name="rootcolor" description="Hair base color" type="color" default="color( .3, .12, .05)"/>
	<input name="tipcolor" description="Hair tip color" type="color" default="color( .89, .82, .54)"/>
    <input name="speccolor1" description="Primary highlights color" type="color" default="color(1, 1, 1)"/>
    <input name="speccolor2" description="Secondary highlights color" type="color" default="color( .96, .56, .26)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
    <output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
        $(Ci) = tshair( $(Ka), $(Kd), $(Ks), $(shift1), $(shift2),
                    $(exponent1), $(exponent2), $(specmask), $(surfacecolor),
                    $(rootcolor), $(tipcolor), $(speccolor1), $(speccolor2),
					$(N), $(I), $(category), DECLARE_AOV_PARAMETERS );
	</rsl_code>
    <usage>Hair shader, based on Thorsten Scheuermann work for the 3d application research group of Ati Inc. The technique described in the paper was meant to be used for polygonal hair models, instead of multiple line/tube approach, being a mix of Kajiya-Kay hair shading model, and Marschner&apos;s model, presented at Siggraph2003. &quot;Ka&quot;, &quot;Kd&quot;, &quot;Ks&quot; have the usual meanings. &quot;Shift1&quot; and &quot;shift2&quot; are the primary and secondary specular highlight shifts, to give some strand specular variation. The primary specular highlight is usually white, the secondary, having some hair color, being these &quot;Cspec1&quot; and &quot;Cspec2&quot;. &quot;Exponent1&quot; and &quot;Exponent2&quot; are the primary and secondary specular exponents, and &quot;specmask&quot; is the specular mask used to give some variation. This block passes the resulting values to the &quot;aov_surfacecolor&quot;, &quot;aov_ambient&quot;, &quot;aov_diffuse&quot; and &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="AshikminDiff" type="function" description="Ashikmin-Shirley diffuse term" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(1)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.9"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.1"/>
	<input name="ior" description="Index of Refraction" type="float" default="3.0"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += anisophongdiff( $(N), $(I), $(Kd), $(Ks), $(category));
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
	<usage>Based on Peter Stuart&apos;s implementation of the Ashikhmin-Shirley model, diffuse term only. The diffuse color value is passed to &quot;aov_surfacecolor&quot;, and the diffuse value, to the &quot;aov_diffuse&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Buratti" type="function" description="Buratti weighted lunar surface" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="weight" description="Weighting factor" type="float" default="0.5"/>
	<input name="density" description="Surface density" type="float" default="0.3"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * Buratti( $(N), $(I), $(weight), $(density),
										$(category) );
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
	<usage>Buratti photometric model, a combination of the Lommel-Seeliger lunar scattering law, and Lambert&apos;s law, the parameter &quot;weight&quot; describing the fraction of light that is multiply scattered, with 1 corresponding to single scattering, and the parameter &quot;density&quot; corresponding to the surface density for the macroscopic roughness function. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="Diffuse" description="Computes diffuse light at surface" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
	<input name="Kd" description="The diffuse coefficient" type="float" default="1"/>
	<input name="N" description="The surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="P" description="Surface position, see usage" storage="varying" type="point" default="P"/>
	<input name="coneangle" description="Cone angle, see usage" type="float" default="PI/2"/>
	<input name="model" description="Toggle 1 or 3 argument diffuse, see usage" storage="uniform" type="float" default="0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_code>
		aov_surfacecolor += $(Cdiff);

		/* Pixie&apos;s diffuse() has 2 forms */
		#define $(blockname)_$(model)
		#if RENDERER == pixie &amp;&amp; defined $(blockname)_1
			aov_diffuse += $(Kd) * diffuse( $(P), $(N), $(coneangle) );
		#else
			aov_diffuse += $(Kd) * diffuse( $(N) );
		#endif /* RENDERER */
		#undef $(blockname)_$(model)

		$(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
<usage>Lambertian Diffuse term. The diffuse color value is passed to the &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets. Pixie&apos;s diffuse shadeop has 2 forms, the first one with a single argument, with the surface normal &quot;N&quot;, the second form, with 3 arguments, allowing the surface position and cone angle (in radians) to be specified as well. The default cone angle is PI/2. The variable &quot;model&quot; toggles between the single argument &quot;diffuse&quot; (0), and the 3 arguments &quot;diffuse&quot; (1).</usage>
</shrimp>

<shrimp type="function" name="DiffuseFalloff" description="Lambertian diffuse falloff block" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
	<input name="Kd" description="Diffuse coefficient" type="float" default="1"/>
	<input name="falloff" description="Diffuse falloff" type="float" default="0.5"/>
	<input name="N" description="The surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="The amount of diffuse light" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * diffusefalloff(	$(falloff), $(N), $(I),
										$(category) );
		$(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
<usage>Lambertian diffuse fall-off model, with control over the falloff between the lit and unlit regions on the surface via the &quot;falloff&quot; variable - this value should be in the [0,1] range. The diffuse color value is passed to &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>

</shrimp>

<shrimp name="HapkeLunar" type="function" description="Hapke-Lommel-Seeliger lunar surface BRDF." author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="density" description="Surface density" type="float" default="0.6"/>
    <input name="scattering" description="Forward scattering" type="float" default="0.1"/>
    <input name="reflectivity" description="Reflectivity" type="float" default="1.0"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * Hapke(	$(density), $(scattering),
										$(reflectivity), $(N), $(I),
										$(category) );
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
    <usage>Based on Szymon Rusinkiewicz&apos;s implementation of the Hapke-Lommel-Seeliger lunar surface BRDF, with Schonberg backstattering and Hapke retrodirective function. The &quot;density&quot; parameter controls the density of the surface. The &quot;scattering&quot; parameter, controls the forward scattering of the surface, and the &quot;reflectivity&quot; parameter, the surface reflectivity. The diffuse color value is passed to the &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets.The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="LommelSeeliger" type="function" description="Lommel-Seeliger lunar surface model" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="depth" description="Layer optical depth, see info" type="float" default="0.2"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * LommelSeeliger( $(N), $(I), $(depth),
								$(category) );
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
	<usage>Lommel-Seeliger lunar surface model for spherical surfaces. The variable &quot;depth&quot; (&quot;tau&quot;) controls the optical thickness of the layer. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Minnaert" type="function" description="Minnaert limb darkening diffuse term" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="weight" description="Limb darkening coefficient" type="float" default="2.0"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * Minnaert( $(weight), $(N), $(I), $(category) );
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
	<usage>Minnaert limb darkening term, with the limb darkening parameter &quot;weight&quot;, controlling the reflectance deviation from the Lambertian term (&quot;k&quot;=1) - the range of this variable is therefore [1,2], while other variants put this limb darkening parameter in the [0,1] range. The diffuse color value is passed to &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="OrenNayar" type="function" description="OrenNayar diffuse shading model" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="roughness" description="roughness" type="float" default="0.05"/>
	<input name="qualitative" description="Toggle qualitative or full model" type="float" storage="uniform" default="1"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
	#define use_qualitative_$(qualitative)
		aov_surfacecolor += $(Cdiff);
	
	#ifdef use_qualitative_1
		/* Air&apos;s diffuse can take a roughness parameter, in which */
		/* case behaves as the Oren-Nayar (qualitative?) model */
		#if RENDERER == air
			aov_diffuse += $(Kd) * diffuse( $(N), $(roughness) );
		#else
			aov_diffuse += $(Kd) * OrenNayar(	$(roughness), $(N), $(I),
												$(category) );
		#endif /* RENDERER */
        $(Ci) = aov_surfacecolor * aov_diffuse;
	#else
		aov_diffuse += $(Kd) * LG_OrenNayar( $(Cdiff), $(roughness), $(N),
												$(I), $(category) );
		$(Ci) = aov_diffuse;
	#endif /* use_qualitative_$(qualitative) */
	#undef use_qualitative_$(qualitative)
	
	</rsl_code>
    <usage>Oren-Nayar diffuse term. This block has both the &quot;qualitative&quot; model based on Szymon Rusinkiewicz's implementation, and the full model with inter-reflections, based on Larry Gritz's implementation, depending on the content of the qualitative variable in the block. The roughness parameter controls the standard deviation of angle orientations of the surface grooves, so when roughness = 0, the term is Lambertian. The diffuse color value is passed to the aov_surfacecolor, and the diffuse value to the aov_diffuse AOV presets, only for the qualitative model (see the header for the C3 coefficient and L1 and L2 variables). The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="OrenNayarWolff" type="function" description="OrenNayarWolff diffuse shading model" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="roughness" description="roughness" type="float" default="0.05"/>
	<input name="ior" description="Index of refraction" type="float" storage="uniform" default="1.5"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		
		aov_diffuse += $(Kd) * OrenNayarWolff( $(roughness), $(ior),
								$(Cdiff), $(N), $(I), $(category) );
        $(Ci) = aov_diffuse;
	</rsl_code>
    <usage>Oren-Nayar-Wolff diffuse term for mildly rough dielectric surfaces, based on the paper &quot;Improved Diffuse Reflection Models for Computer Vision&quot;, by Lawrence B. Wolff, Shree K. Nayar, Michael Oren, and on Larry Gritz&apos;s implementation of the full Oren-Nayar model with inter-reflections, from The RenderMan Repository. Roughness parameter accounts for apparent surface roughness, and the IOR parameter is the index of refraction of the dielectric surface - note that most dielectric surfaces have an IOR in the [1.3,2.0] range. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="RimLight" description="Rim lighting shader" author="rconstruct">
	<input name="Crim" description="Rim color" type="color" default="color(1)"/>
	<input name="intensity" description="Rim coefficient" type="float" default="1"/>
	<input name="rimwidth" description="Rim width" type="float" default="1"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Viewer or user supplied vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="filterwidth" description="Filter width" type="float" default="0.0"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
	#if RENDERER == pixie
		aov_rimlighting += $(Crim) * $(intensity) * float rimlighting(
						$(rimwidth), $(filterwidth), $(N), $(I) );
	#else
		aov_rimlighting += $(Crim) * $(intensity) * rimlighting( $(rimwidth),
						$(filterwidth), $(N), $(I) );
	#endif
		$(Ci) = aov_rimlighting;
	</rsl_code>
<usage>Rim lighting function, returns the cosine of the angle between the surface normal and the viewer vector, altough you can supply an custom vector instead of viewer vector, to get a directional rim lighting effect. The parameter &quot;rimwidth&quot; controls the rim width effect, while the parameter &quot;intensity&quot;, controls the rim intensity. You can specify an filter width, via the parameter &quot;filterwidth&quot;, in which case the function uses &quot;filteredsmoothstep&quot; instead of &quot;smoothstep&quot;. This value is passed to the &quot;aov_rimlighting&quot; AOV preset.</usage>
</shrimp>

<shrimp name="Wolff" type="function" description="Wolff diffuse term" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
    <input name="Kd" description="Diffuse light coefficient" type="float" default="0.8"/>
	<input name="ior" description="Index of refraction" type="float" default="1.5"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * Wolff( $(N), $(I), $(ior), $(category) );
        $(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
	<usage>Wolff diffuse model for smooth dielectric surfaces, based in the paper &quot;Improved Diffuse Reflection Models for Computer Vision&quot;, by Lawrence B. Wolff, Shree K. Nayar, and Michael Oren. The &quot;ior&quot; parameter usually should be in the [1.3,2.0] range. The diffuse color value is passed to the &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="WDiffuse" description="Wrapped diffuse lighting model" author="rconstruct">
	<input name="Cdiff" description="Diffuse color" type="color" default="color(.5)"/>
	<input name="Kd" description="Diffuse coefficient" type="float" default="1"/>
	<input name="wrapangle" description="Wrapped angle" type="float" default="radians(90)"/>
	<input name="attenuation" description="Diffuse attenuation" type="float" default="5"/>
	<input name="N" description="The surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="The viewer vector" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="The amount of diffuse light" type="color"/>
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_surfacecolor += $(Cdiff);
		aov_diffuse += $(Kd) * wrappeddiffuse( $(wrapangle), $(attenuation),
						$(N), $(I), $(category) );
		$(Ci) = aov_surfacecolor * aov_diffuse;
	</rsl_code>
<usage>Wrapped diffuse illumination model, allows light to reach beyond 90 degrees on the surface, overcoming one limitation of classical Lambertian diffuse term, the steep falloff to shadow areas. The diffuse color value is passed to &quot;aov_surfacecolor&quot;, and the diffuse value to the &quot;aov_diffuse&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>

</shrimp>

<shrimp name="AshikminSpec" type="function" description="Ashikmin-Shirley anisotropic specular term" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.9"/>
	<input name="ior" description="Index of Refraction" type="float" default="2.0"/>
    <input name="nu" description="specularity along U direction" type="float" default="100"/>
    <input name="nv" description="specularity along V direction" type="float" default="5"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * anisophongspec( $(N), $(I), $(nu), $(nv),
						$(ior), $(category) );
        $(Ci) = aov_specularcolor * aov_specular;

	</rsl_code>
	<usage>Based on Peter Stuart&apos;s implementation of the Ashikmin-Shirley anisotropic BRDF, here, the isolated specular term only. &quot;Nu&quot; and &quot;Nv&quot; control the specularity in the anisotropy X and Y directions respectively, while &quot;ior&quot; controls the index of refraction for the Fresnel term. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value is passed to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="CookTorrance" type="function" description="Cook-Torrance shading model." author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1.0"/>
    <input name="roughness" description="The apparent surface roughness."  type="float" default="0.2"/>
	<input name="distribution" description="Microfacet distributions, see help." storage="uniform" type="float" default="0"/>
	<input name="attenuation" description="Geometric attenuation, see help." storage="uniform" type="float" default="0"/>
    <input name="ior" description="Index of refraction" type="float" default="2"/>
	<input name="extinction" description="Extinction coefficient" type="float" default="2"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="I"/>
	<input name="direction" description="Anisotropy direction" storage="varying" type="vector" default="dPdv"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * cooktorrance( $(N), $(I), $(direction),
						$(ior), $(extinction), $(roughness),
						$(distribution), $(attenuation), $(category));
		$(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Cook-Torrance specular term. The &quot;distribution&quot; variable controls the microfacet distribution function being used, being 0 = Beckmann (default), 1 = Ward, 2 = Trowbridge-Reitz, 3 = Heidrich-Seidel (anisotropic). The &quot;attenuation&quot; variable controls the geometric attenuation function being used, being 0 = the default shadowing/masking function proposed by Blinn for the Torrance-Sparrow model, 1 = the approximation suggested by Christophe Schlick for the first Smith shadowing/masking equation for a known microfacet normal, 2 = full Smith second equation for an averaged microfacet normal (as used in the He-Torrance model). In the case of the Heidrich-Seidel anisotropic distribution, some literature mentions adding an isotropic specular term, which is added here via &quot;specularbrdf&quot;, but the user might want to override this in the respective header - this distribution uses the anisotropy direction defined by &quot;direction&quot;, which defaults to the global variable &quot;dPdv&quot;. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value is passed to the &quot;aov_specular&quot; AOV presets. The Fresnel term used is the complex Fresnel function, from the Odforce.net Odwiki, courtesy of Mario Marengo and the Odforce community, using the &quot;ior&quot; index of refraction, and the &quot;extinction&quot; extinction coefficient. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="Glossy" type="function" description="Possible replacement for specular()" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.9"/>
    <input name="roughness" description="The specular highlight roughness" type="float" default="0.2"/>
    <input name="size" description="The specular highlight size" type="float" default="0.5"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
    <rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * LocIllumGlossy( $(N), $(I), $(roughness),
												$(size), $(category) );
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Larry Gritz&apos;s glossy &quot;specular&quot;. Possible replacement for &quot;specular&quot;, with a more uniformly bright core and sharper falloff. Good specular function for something made of glass or liquid, in which roughness is related to the size of the specular highlight, larger is bigger, and sharpness = 1 is infinitely sharp, 0 is very dull. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="Phong" description="Computes Phong specular light at surface" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
	<input name="Ks" description="Specular coefficient" type="float" default="1"/>
	<input name="N" description="The surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="V" description="The viewer vector" storage="varying" type="vector" default="-normalize(I)"/>
	<input name="size" description="The specular highlight size" type="float" default="15"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * phong( $(N), $(V), $(size));
		$(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
	<usage>Specular term, using the Phong model. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets.</usage>
</shrimp>

<shrimp name="PhongBlinn" type="function" description="Phong-Blinn specular term." author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.8"/>
    <input name="size" description="Specular size." type="float" default="15"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * phong_blinn( $(N), $(I), $(size), $(category));
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Phong-Blinn specular term. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="SchlickAniso" type="function" description="Schlick anisotropic specular term." author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1"/>
    <input name="roughness" description="The apparent surface roughness." type="float" default="0.2"/>
	<input name="isotropy" description="Surface isotropy" type="float" default="0.1"/>
	<input name="ior" description="Index of refraction" type="float" default="2.0"/>
	<input name="direction" description="Anisotropy direction" storage="varying" type="vector" default="normalize(dPdu)"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * aschlick( $(roughness), $(isotropy),
						$(ior), $(N), $(I), $(direction), $(category) );
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Christope Schlick&apos;s anisotropic specular term. &quot;isotropy&quot; controls surface isotropy, 0 being anisotropic, 1 being isotropic; &quot;roughness&quot; controls apparent surface roughness, 0 being smooth, 1 being rough; &quot;ior&quot;, the index of refraction controls the reflection coefficient contribution from the Fresnel term; &quot;direction&quot; is the anisotropy direction, defaults to &quot;dPdu&quot;. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="SchlickIso" type="function" description="Schlick isotropic specular term." author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="1"/>
    <input name="roughness" description="The apparent surface roughness." type="float" default="0.3"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * schlickspec(	$(N), $(I), $(roughness),
												$(category) );
		$(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Christope Schlick&apos;s isotropic specular term. &quot;Roughness&quot; controls the apparent surface roughness. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="SHW_brushedmtal" type="function" description="Stephen H.Westin anisotropic shader" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.8"/>
    <input name="roughness" description="The apparent roughness of the surface." type="float" default="0.1"/>
    <input name="direction" description="Anisotropy direction" storage="varying" type="vector" default="normalize(dPdu)"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * shw_brushed_metal( $(roughness), $(N),
						$(I), $(direction), $(category) );
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Stephen Westin&apos;s anisotropic specular term, using Kajiya&apos;s Phong-like highlight from a cylinder (Siggraph 89) coupled with an arbitrary shadowing/masking function. &quot;Roughness&quot; controls the apparent surface roughness, &quot;direction&quot; is the anisotropy direction, defaulting to &quot;dPdu&quot;. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value, to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="Specular" description="Computes specular light at surface" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
	<input name="Ks" description="Specular coefficient" type="float" default="1"/>
	<input name="N" description="The surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="V" description="The viewer vector" storage="varying" type="vector" default="-normalize(I)"/>
	<input name="roughness" description="The specular roughness" type="float" default="0.3"/>
	<output name="Ci" description="The amount of diffuse light" type="color" />
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * specular( $(N), $(V), $(roughness) );
		$(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
<usage>Specular term, using the &quot;specular&quot; function. Note that what is a standard &quot;specular&quot; might vary with the renderer you&apos;re using. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value is passed to the &quot;aov_specular&quot; AOV presets.</usage>
</shrimp>

<shrimp name="WardAniso" type="function" description="Greg Ward Larson anisotropic shading model" author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.3"/>
    <input name="uroughness" description="The apparent roughness of the surface in xdir." type="float" default="0.6"/>
    <input name="vroughness" description="The apparent roughness of the surface in a tangent perpendicular to xdir" type="float" default="0.15"/>
    <input name="direction" description="Anisotropy direction" storage="varying" type="vector" default="normalize(dPdv)"/>
	<input name="N" description="Surface normal" storage="varying" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" storage="varying" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * LocIllumWardAnisotropic( $(N), $(I),
						$(direction), $(uroughness), $(vroughness),
						$(category) );
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Gregory J. Ward&apos;s anisotropic specular term. &quot;Uroughness&quot; and &quot;vroughness&quot; control the apparent surface roughness in the anisotropy X and Y directions respectively, being the default direction &quot;dPdv&quot; as defined in &quot;direction&quot;. The specular color value is passed to &quot;aov_specularcolor&quot;, while the specular value is passed to the &quot;aov_specular&quot; AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp name="WardIso" type="function" description="Ward isotropic specular term." author="rconstruct">
	<input name="Cspec" description="Specular color" type="color" default="color(1)"/>
    <input name="Ks" description="Specular light coefficient" type="float" default="0.8"/>
    <input name="roughness" description="The surface roughness." type="float" default="0.2"/>
	<input name="N" description="Surface normal" type="vector normal" default="normalize(N)"/>
	<input name="I" description="Direction of viewer" type="vector" default="normalize(I)"/>
	<input name="category" description="Light categories accepted" storage="uniform" type="string" default="&quot;&quot;" />
	<output name="Ci" description="Shaded color" type="color" />
	<rsl_include>rsl_shadingmodels.h</rsl_include>
	<rsl_code>
		aov_specularcolor += $(Cspec);
		aov_specular += $(Ks) * Wardisotropy( $(N), $(I), $(roughness),
									$(category) );
        $(Ci) = aov_specularcolor * aov_specular;
	</rsl_code>
    <usage>Simplified isotropic version of Greg Ward's anisotropic specular term. Note that you can get equivalent results with the anisotropic shader, by passing identical values to the surface roughness along the anisotropy direction, and anisotropy perpendicular direction. Roughness controls the apparent surface roughness. The specular color value is passed to aov_specularcolor, while the specular value, to the aov_specular AOV presets. The &quot;category&quot; variable defines the light categories used for the &quot;illuminance&quot; construct of this block.</usage>
</shrimp>

<shrimp type="function" name="Concat" description="Concatenates two or more strings" author="rconstruct">
	<input name="string1" description="First string" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="string2" description="Second and subsequent strings" storage="uniform" type="string" default="&quot;&quot;" multi=","/>
	<output name="newstring" description="Concatenated string" storage="uniform" type="string"/>
	<rsl_code>
		$(newstring) = concat( $(string1), $(string2) );
	</rsl_code>
	<usage>Concatenates two or more strings into a single string.</usage>
</shrimp>

<shrimp type="function" name="Format" description="Formats a string" author="rconstruct">
	<input name="pattern" description="String pattern" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="string" description="String to search" storage="uniform" type="string" default="&quot;&quot;" multi=","/>
	<output name="newstring" description="Formatted string" storage="uniform" type="string"/>
	<rsl_code>
		$(newstring) = format( $(pattern), $(string) );
	</rsl_code>
	<usage>Similar to &quot;sprintf&quot; in C, formats a string according to string pattern. The formatting for the string uses &quot;%f&quot;, &quot;%c&quot;, &quot;%p&quot;, &quot;%m&quot; and &quot;%s&quot;, for variables of type float, color, normal/vector/point, matrix, and string respectively. This function might vary with some renderer&apos;s implementations.</usage>
</shrimp>

<shrimp type="function" name="Match" description="Searches subject string for pattern string" author="rconstruct">
	<input name="pattern" description="Pattern string" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="string" description="String to search" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="status" description="Return status" storage="uniform" type="float"/>
	<rsl_code>
		$(status) = match( $(pattern), $(string) );
	</rsl_code>
	<usage>Searches subject string for pattern string, and returns 1 if the pattern exists in the subject, otherwise it returns 0. The pattern can be any regex expression (man regex for more information).</usage>
</shrimp>

<shrimp type="function" name="Printf" description="Prints values of variables" author="rconstruct">
	<input name="string" description="String to use, see usage" storage="uniform" type="string" default="&quot;Content of var =&quot;"/>
	<input name="variable" description="Variable input" type_parent="value" type="color normal vector point matrix string float" default="0"/>
	<output name="value" description="Variable output" type="color normal vector point matrix string float"/>
	<rsl_code>
	
	#define $(blockname)_$(variable:type) 1
	#ifdef $(blockname)_float
		printf( concat( $(string), " %f\n"), $(variable) );
	#elif $(blockname)_color
		printf( concat( $(string), " %c\n"), $(variable) );
	#elif $(blockname)_matrix
		printf( concat( $(string), " %m\n"), $(variable) );
	#elif $(blockname)_string
		printf( concat( $(string), " %s\n"), $(variable) );
	#else
		printf( concat( $(string), " %p\n"), $(variable) );
	#endif /* $(blockname)_$(variable:type) */
	#undef $(blockname)_$(variable:type)
	
		$(value) = $(variable);
		
	</rsl_code>
	<usage>Similar to the C &quot;printf&quot;, prints the contents of the specified variables into stdout. The formatting for the string uses &quot;%f&quot;, &quot;%c&quot;, &quot;%p&quot;, &quot;%m&quot; and &quot;%s&quot;, for variables of type float, color, normal/vector/point, matrix, and string. The string has the variable type and a newline concatenated. See block code for details.</usage>
</shrimp>

<shrimp type="function" name="Bake" description="Bakes associated data" author="rconstruct">
	<input name="bakefile" description="Baked map filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="s" description="X coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Y coordinate" storage="varying" type="float" default="t"/>
	<input name="bakedata" description="Data to bake" type="point color float" type_parent="bdataout" default="0"/>
	<input name="ascii" description="ASCII/binary file toggle" type="float" default="1"/>
	<output name="data" description="Baked data" type="point color float" />
	<rsl_code>
	
	#if RENDERER==aqsis
		bake( $(bakefile), $(s), $(t), $(bakedata) );
		$(data) = $(bakedata);
		
	#elif RENDERER==_3delight
	/* default is to save in ASCII format */
	#define bakeformat_$(ascii)
	#ifdef bakeformat_1
		bake( $(bakefile), $(s), $(t), $(bakedata) );
		$(data) = $(bakedata);
	#else
		bake( concat( $(bakefile), "&amp;binary"), $(s), $(t), $(bakedata) );
		$(data) = $(bakedata);
	#endif /* bakeformat_$(ascii) */
	#undef bakeformat_$(ascii)
		
	#else
	/* bake() is only supported on Aqsis and 3delight */
		$(data) = $(bakedata);
	#endif /* RENDERER */
			
	</rsl_code>
<usage>Bakes the supplied data channel into a bakefile. In 3Delight&apos;s case, you can force the baked file to be in binary format, instead of ASCII format, by toggling the ascii parameter, which is enabled (ascii on) by default. Check your renderer&apos;s documentation, since this function is isn&apos;t available in all renderers.</usage>
</shrimp>

<shrimp type="function" name="Bake3d" description="Bakes associated data" author="rconstruct">
	<input name="bakefile" description="Baked map filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<input name="coordsys" description="Coordinate system" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="filterradius" description="Filter radius" storage="varying" type="float" default="1"/>
	<input name="filterscale" description="Filter scale" type="float" default="1"/>
	<input name="interpolate" description="Toggle interpolation" type="float" default="1"/>
	<input name="bakechannel" description="Data channel to bake" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="bakedata" description="Value associated with data channel" type_parent="bakevalue" storage="varying" type="point vector normal float color" default="color(0)" />
	<output name="bakevalue" description="Baked data value" type="point vector normal float color" />
	<output name="status" description="Status" type="float"/>
	<rsl_code>
	
	#if RENDERER == pixie
		$(status) = bake3d( $(bakefile), $(bakechannel), $(P), $(N),
							"coordsystem", $(coordsys),
							"interpolate", $(interpolate), 
							"radius", $(filterradius),
							"radiusscale", $(filterscale),
							$(bakechannel), $(bakedata) );
		$(bakevalue) = $(bakedata);
		
	#elif RENDERER == _3delight
	/* DisplayChannels are ignored in bake3d() (as of 8.5) */
		$(status) = bake3d(	$(bakefile), "", $(P), $(N),
							"coordsystem", $(coordsys),
							"radius", $(filterradius),
							"radiusscale", $(filterscale),
							"interpolate", $(interpolate),
							$(bakechannel), $(bakedata) );
		$(bakevalue) = $(bakedata);
		
	#elif RENDERER == prman
		$(status) = bake3d(	$(bakefile), $(bakechannel), $(P), $(N),
							"coordsystem", $(coordsys),
							"radius", $(filterradius),
							"radiusscale", $(filterscale),
							"interpolate", $(interpolate),
							$(bakechannel), $(bakedata) );
		$(bakevalue) = $(bakedata);
		
	#elif RENDERER == air
		$(status) = bake3d(	$(bakefile), $(P), $(N),
							"radius", $(filterscale),
							"radiusscale", $(filterradius),
							$(bakechannel), $(bakedata) );
		$(bakevalue) = $(bakedata);

	#else
		$(bakevalue) = $(bakedata);
		$(status) = 0;
	#endif /* RENDERER */
			
	</rsl_code>
	<usage>This function bakes the supplied data channel into a bakefile. Note that this varies considerably with each renderer&apos;s implementation, please check your renderer&apos;s documentation for details. Returns 1 if sucessful, 0 if failed.</usage>
</shrimp>

<shrimp type="function" name="Environment" description="Access a environment map" author="rconstruct">
	<input name="texmap" description="Texture map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="Kr" description="Environment intensity" type="float" default="1"/>
	<input name="direction" description="Direction vector" storage="varying" type="normal vector" default="reflect( I, normalize(N))"/>
    <input name="sblur" description="Blur along S" storage="varying" type="float" default="0"/>
    <input name="tblur" description="Blur along T" storage="varying" type="float" default="0"/>
    <input name="swidth" description="Blur filter width along S" storage="uniform" type="float" default="1"/>
    <input name="twidth" description="Blur filter width along T" storage="uniform" type="float" default="1"/>
	<input name="samples" description="Sampling rate" storage="uniform" type="float" default="4"/>
    <input name="fill" description="Fill value on empty channel" type="float" storage="uniform" default="0"/>
    <input name="filter" description="Filter type" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
    <input name="channel" description="Channel, in color textures" type="float" default="0"/>
	<input name="tint" description="Color tint for the environment" type="color" type_parent="value" default="1"/>
	<input name="label" description="Ray label" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="subset" description="Ray subset" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="bias" description="Ray bias" storage="uniform" type="float" default="-1"/>
	<input name="hitmode" description="Override hitmode" storage="uniform" type="string" default="&quot;default&quot;"/>
	<input name="maxdist" description="Maximum ray distance" type="float" default="1e38"/>
	<input name="coneangle" description="Cone angle" type="float" default="radians(5)"/>
	<input name="expandLDR" description="Expand range of LDR image" storage="uniform" type="float" default="0"/>
	<input name="dynrange" description="Maximum value to expand range to" type="float" default="1"/>
	<input name="startlum" description="Starting luminance for expansion" type="float" default="0.5"/>
	<input name="exponent" description="Range exponent for falloff" type="float" default="2.0"/>
	<output name="value" description="Output color" type="float color"/>
	<rsl_include>rsl_texture.h</rsl_include>
	<rsl_code>

	/* make sure options are clear and set them according to shadeop
	 * and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif
	
    #if RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"filter", $(filter), \
								/* can't specify s/tblur */ \
								"blur", $(sblur), \
								"swidth", $(swidth), "twidth", $(twidth),\
								"fill", $(fill), "samples", $(samples), \
								"bias", $(bias), "maxdist", $(maxdist), \
								"samplecone", $(coneangle), "label", $(label)
	#elif RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	"sblur", $(sblur), "tblur", $(tblur), \
								"swidth", $(swidth), "twidth", $(twidth),\
								"samples", $(samples), "fill", $(fill), \
								"filter", $(filter), "label", $(label), \
								"subset", $(subset), "bias", $(bias), \
								"hitmode", $(hitmode), \
								"maxdist", $(maxdist)
    #elif RENDERER == air
	#define SHADEOP_ARGUMENTS	"bias", $(bias), \
								/* can't specify s/blur */ \
								"blur", $(sblur), "label", $(label), \
								"maxdist", $(maxdist), \
								"samples", $(samples), \
								"subset", $(subset)
	#else
	#define SHADEOP_ARGUMENTS	"sblur", $(sblur), "tblur", $(tblur), \
								"swidth", $(swidth), "twidth", $(twidth),\
								"samples", $(samples), \
								"filter", $(filter), \
								"fill", $(fill)
    #endif /* RENDERER */
	
	// LDR expansion, from SIGGRAPH 2002 Course 16,
	// &quot;Production Ready GI&quot;, by Hayden Landis
	#define $(blockname)_expandLDR $(expandLDR)
	#if $(blockname)_expandLDR == 1
		varying $(value:type) $(blockname)_ctmp = $(Kr) * $(tint) *
				$(value:type) environment(	$(texmap)[$(channel)],
											$(direction),
											SHADEOP_ARGUMENTS );
		$(value) = envexpand(	$(blockname)_ctmp, $(dynrange),
								$(startlum), $(exponent) );
	#else // no expansion
	// tint is of float type if output variable is of float type
		$(value) = $(Kr) * $(tint) * $(value:type) environment(
						$(texmap)[$(channel)],
						$(direction),
						SHADEOP_ARGUMENTS );
	#endif // expandLDR
	aov_reflection += $(value);

	#undef $(blockname)_expandLDR
	#undef SHADEOP_ARGUMENTS
	
	</rsl_code>
<usage>This block returns the texture value from an environment map, for the specified direction vector. If the filename specified is &quot;raytrace&quot; then raytracing is used instead of a texture map. The variables &quot;sblur&quot; and &quot;tblur&quot; specify the blur along the &quot;S&quot; and &quot;T&quot; directions respectively, while &quot;swidth&quot; and &quot;twidth&quot; specify the filter width along the &quot;S&quot; and &quot;T&quot; directions respectively. The filter type can be &quot;box&quot;, &quot;triangle&quot;, or &quot;gaussian&quot;, with &quot;samples&quot; controling the number of samples to use. The starting channel is specified with the &quot;channel&quot; parameter. The type returned can be float, or color, and it is passed to the preset &quot;aov_reflection&quot; AOV. When raytracing is used, extra parameters available to raytracing functions are available, such as &quot;label&quot;, &quot;subset&quot;, &quot;bias&quot; and &quot;hitmode&quot;. Note that this function might vary considerably with each renderer, so please check your renderer&apos;s documentation. This block also implements the LDR expansion from SIGGRAPH 2002 Course 16, &quot;Production Ready GI&quot;, by Hayden Landis, to avoid washed out reflection highlights when using Low Dynamic Range images for reflection maps. When toggling &quot;expandLDR&quot; on/off, the following variables apply to control the expansion: &quot;dynrange&quot;, defines the maximum value to expand the specified region of the map to; &quot;startlum&quot;, defines the starting luminance for the expansion to begin with; &quot;exponent&quot;, defines the exponent for the falloff.</usage>
</shrimp>

<shrimp type="function" name="NumTexChannels" description="Number of texture channels" author="rconstruct">
	<input name="texmap" description="Texture map" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="value" description="Adjusted value." storage="uniform" type="float"/>
	<rsl_include>rsl_texture.h</rsl_include>
	<rsl_code>
	$(value) = numtexchannels( $(texmap) );
	</rsl_code>
	<usage>This block returns the number of channels in a texture map.</usage>
</shrimp>

<shrimp type="function" name="ProjectTex" description="Project texture, get color and opacity." author="rconstruct">
	<input name="texmap" description="Texture map" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="projection" description="Projection to use" storage="uniform" type="string" default="&quot;st&quot;"/>
	<input name="whichspace" description="Space to use for projection" storage="uniform" type="string" default="&quot;shader&quot;"/>
	<input name="graymode" description="Grayscale conversion mode" storage="uniform" type="string" default="&quot;luminance&quot;"/>
	<input name="xform" description="Transformation matrix" storage="uniform" type="matrix" default="1"/>
	<input name="channel" description="Optional channel for grayscale conversion" storage="uniform" type="float" default="0"/>
	<input name="blur" description="Texture blur" type="float" default="0"/>
	<input name="samples" description="Texture samples" storage="uniform" type="float" default="1"/>
	<input name="filter" description="Filter type" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="width" description="Filter width" storage="uniform" type="float" default="1"/>
	<input name="maxwidth" description="Maximum filter width" storage="uniform" type="float" default="1"/>
	<input name="P" description="Surface point" type="point" default="P"/>
	<input name="N" description="Surface normal" type="normal" default="normalize(N)"/>
	<input name="widthrepeat" description="Repeat width" type="float" default="1"/>
	<input name="heightrepeat" description="Repeat height" type="float" default="1"/>
	<input name="xpatoffsetw" description="X offset width" type="float" default="0"/>
	<input name="xpatoffseth" description="X offset height" type="float" default="0"/>
	<input name="ypatoffsetw" description="Y offset width" type="float" default="0"/>
	<input name="ypatoffseth" description="Y offset height" type="float" default="0"/>
	<input name="zpatoffsetw" description="Z offset width" type="float" default="0"/>
	<input name="zpatoffseth" description="Z offset height" type="float" default="0"/>
	<input name="xinverts" description="Invert S on X plane" storage="uniform" type="float" default="0"/>
	<input name="yinverts" description="Invert S on Y plane" storage="uniform" type="float" default="0"/>
	<input name="zinverts" description="Invert S on Z plane" storage="uniform" type="float" default="0"/>
	<input name="fixseams" description="Fix wrapping seams" storage="uniform" type="float" default="0"/>
	<output name="mapcolor" description="Texture color" storage="varying" type="color"/>
	<output name="mapopacity" description="Texture opacity" storage="varying" type="color"/>
	<rsl_include>rsl_texture.h</rsl_include>
	<rsl_code>
		$(mapcolor) = color(0);
		$(mapopacity) = color(0);
		getcolorandalpha(	$(texmap), $(projection), $(whichspace),
							$(graymode), $(xform), $(channel), $(blur),
							$(samples), $(filter), $(width), $(maxwidth),
							$(P), $(N), $(widthrepeat), $(heightrepeat),
							$(xpatoffsetw), $(xpatoffseth),
							$(ypatoffsetw), $(ypatoffseth),
							$(zpatoffsetw), $(zpatoffseth),
							$(xinverts), $(yinverts), $(zinverts),
							$(fixseams), $(mapcolor), $(mapopacity) );
	</rsl_code>
	<usage>This block projects textures and retrieves the color and opacity values. The variables used are: &quot;texmap&quot;, the texture map to use; &quot;projection&quot;, the projection to use, being &quot;box&quot;, &quot;perspective&quot;, &quot;cylindrical&quot;, &quot;spherical&quot;, and &quot;st&quot; the allowed types, defaulting to &quot;st&quot;; &quot;whichspace&quot;, in which space to do the transformations for the projections; &quot;graymode&quot;, if the texture has enough channels, how do to the color to grayscale conversion for the alpha channel - the allowed modes being the same as in the &quot;ToGrayscale&quot; block, namely: &quot;minimum&quot;, &quot;maximum&quot;, and &quot;average&quot; the minimum, maximum, and average of the color components (if there are at least 3 color components), and &quot;luminance&quot; and &quot;channel&quot; doing the conversion from color to grayscale using CIE luminance function, or by using the channel specified in &quot;channel&quot; as the grayscale value used for the alpha channel. If the texture has 6 textures, the opacity map is a color map, that uses the channel 3, 4 and 5 respectively for R, G and B. The remaining variables are: &quot;blur&quot;, the blur parameter passed to the &quot;texture&quot; shadeop; &quot;samples&quot;, the samples used for the &quot;texture&quot; shadeop, only valid when the filter type is &quot;box&quot;, which can be defined in &quot;filter&quot;; &quot;width&quot; and &quot;maxwidth&quot; controlling the filter width and maximum width respectively; &quot;P&quot; and &quot;N&quot; the surface point P and normalized surface normal N. The following variables are used to control the &quot;box&quot; projection, being: &quot;repeatwidth&quot; and &quot;repeatheight&quot;, the number of times the texture repeats in width and height for each of the face&apos;s projections; &quot;xpatoffsetw&quot;, &quot;xpatoffseth&quot;, &quot;ypatoffsetw&quot;, &quot;ypatoffseth&quot;, &quot;zpatoffsetw&quot;, &quot;zpatoffseth&quot;, controlling the width and height offsets for each of X, Y and Z coordinates. The variable &quot;fixseams&quot; toggles the use between the normal &quot;texture&quot; shadeop, and Dan Maas&apos;s &quot;clampedtexture&quot; function, from teh SIGGRAPH 2006 course 25, &quot;What the RI Spec never told you&quot;, to control the seams artifacts when wrapping textures.</usage>
</shrimp>

<shrimp type="function" name="ShadowMaps" description="Access a shadow map" author="rconstruct">
	<input name="texmap" description="Texture map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
    <input name="sblur" description="Blur along S" storage="varying" type="float" default="0"/>
    <input name="tblur" description="Blur along T" storage="varying" type="float" default="0"/>
    <input name="swidth" description="Blur filter width along S" storage="uniform" type="float" default="0"/>
    <input name="twidth" description="Blur filter width along T" storage="uniform" type="float" default="0"/>
    <input name="samples" description="Sampling rate" type="float" default="16"/>
	<input name="bias" description="Shadow bias" storage="uniform" type="float" default="0.225"/>
    <input name="filter" description="Filter type" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
    <input name="channel" description="Channel, in color textures" type="float" default="0"/>
	<output name="value" description="Output color" type="float color"/>
	<rsl_code>
	
    #if RENDERER==pixie
        $(value) = $(value:type) shadow( $(texmap), $(P),
								"blur", $(sblur),
								"width", $(swidth),
								"samples", $(samples),
								"bias", $(bias),
                                "filter", $(filter) ) ;
    #else
        $(value) = $(value:type) shadow( $(texmap)[$(channel)], $(P),
								"sblur", $(sblur),
								"tblur", $(tblur),
								"swidth", $(swidth),
								"twidth", $(twidth),
								"samples", $(samples),
								"bias", $(bias),
                                "filter", $(filter) ) ;
    #endif /* RENDERER */

	</rsl_code>
	<usage>Shadow maps compare a point in space with a depth image from the light source viewpoint, to determine if the surface is in shadow or illuminated by the light source. If the texture filename is &quot;raytrace&quot; then raytracing is used to calculate the shadows. Uses a point as texture coordinate, with sblur and tblur, used to control blur in the S and T directions respectively, swidth and twidth used to control the filter width in the S and T directions respectively, with filter defaulting to &quot;box&quot;. Samples controls the sampling rate, and bias is used to control self-shadowing, defaulting to 0, while channel controls the starting channel in shadow maps with multiple channels.</usage>
</shrimp>

<shrimp type="function" name="Texture" description="Access a texture map" author="rconstruct">
	<input name="texmap" description="Texture map name" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="s" description="Horizontal texture coordinate" storage="varying" type="float" default="s"/>
	<input name="t" description="Vertical texture coordinate" storage="varying" type="float" default="t"/>
    <input name="sblur" description="Blur along S" storage="varying" type="float" default="0"/>
    <input name="tblur" description="Blur along T" storage="varying" type="float" default="0"/>
    <input name="swidth" description="Blur filter width along S" storage="uniform" type="float" default="0"/>
    <input name="twidth" description="Blur filter width along T" storage="uniform" type="float" default="0"/>
    <input name="fill" description="Fill value on empty channel" storage="uniform" type="float" default="0"/>
    <input name="filter" description="Filter type" storage="uniform" type="string" default="&quot;gaussian&quot;"/>
	<input name="samples" description="Filter samples, see info" storage="uniform" type="float" default="1"/>
    <input name="channel" description="Channel, in color textures" type="float" default="0"/>
	<output name="value" description="Output color" type="float color"/>
	<rsl_code>

	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif
	
    #if RENDERER==pixie
	#define SHADEOP_ARGUMENTS	/* no s/tblur */ "blur", $(sblur), \
								"swidth", $(swidth), "twidth", $(twidth), \
                                "filter", $(filter), "fill", $(fill) \
								"samples", $(samples)
    #elif RENDERER==_3delight
	#define SHADEOP_ARGUMENTS	"sblur", $(sblur), "tblur", $(tblur), \
								"swidth", $(swidth), "twidth", $(twidth), \
								"filter", $(filter), "fill", $(fill), \
								"samples", $(samples)
	#else
	#define SHADEOP_ARGUMENTS	"sblur", $(sblur), "tblur", $(tblur), \
								"swidth", $(swidth), "twidth", $(twidth), \
                                "filter", $(filter), "fill", $(fill)
    #endif /* RENDERER */

		$(value) = $(value:type) texture(	$(texmap)[$(channel)],
										$(s), $(t),
										SHADEOP_ARGUMENTS );

	#undef SHADEOP_ARGUMENTS
	
	</rsl_code>
<usage>The texture shadeop accesses at texture map at 2D coordinates, being able to return either a float or a color value. The default coordinates are &quot;S&quot; and &quot;T&quot;. The variables &quot;sblur&quot; and &quot;tblur&quot; specifies the blur in the &quot;S&quot; and &quot;T&quot; directions respectively, and &quot;swidth&quot; and &quot;twidth&quot; specifying the filter width in &quot;S&quot; and &quot;T&quot; respectively. The variable &quot;filter&quot; can be one of &quot;triangle&quot;, &quot;box&quot;, or &quot;gaussian&quot;. &quot;Fill&quot; controls the value being output if a certain channel isn&apos;t available in the texture, alpha for instance. &quot;Samples&quot; is used only in 3delight when the &quot;box&quot; filter is being used. Pixie has a &quot;blur&quot; parameter, that specifies the blur of the texture, but since you can&apos;t specify blur along &quot;S&quot; or &quot;T&quot; specifically, this value is the value of &quot;sblur&quot;. The &quot;samples&quot; value is used as well, for the &quot;box&quot; filter only. Since a texture map can contain several channels, &quot;channel&quot; allows the user to choose the starting channel, defaults to 0.</usage>
</shrimp>

<shrimp type="function" name="Texture3d" description="Lookups on bake3d files" author="rconstruct">
	<input name="bakefile" description="Baked map filename" storage="uniform" type="string" default="&quot;&quot;"/>
	<input name="P" description="Surface point" storage="varying" type="point" default="P"/>
	<input name="N" description="Surface normal" storage="varying" type="normal" default="normalize(N)"/>
	<input name="coordsys" description="Coordinate system" storage="uniform" type="string" default="&quot;world&quot;"/>
	<input name="filterradius" description="Filter radius" type="float" default="1"/>
	<input name="filterscale" description="Filter scale" type="float" default="1"/>
	<input name="interpolate" description="Toggle interpolation" type="float" default="1"/>
	<input name="maxdepth" description="Maximum lookup depth" type="float" default="1"/>
	<input name="channel" description="Data channel to query" storage="uniform" type="string" default="&quot;&quot;"/>
	<output name="channeldata" description="Value associated with data channel" type="color point vector normal matrix float"/>
	<output name="status" description="Status" type="float"/>
	<rsl_code>
	
	/* make sure options are clear */
	/* and set them according to shadeop and renderer */
	#ifdef SHADEOP_ARGUMENTS
	#undef SHADEOP_ARGUMENTS
	#endif /* SHADEOP_ARGUMENTS */
	
	#if RENDERER == pixie
	#define SHADEOP_ARGUMENTS	"coordsystem", $(coordsys), \
								"interpolate", $(interpolate), \
								"radius", $(filterradius), \
								"radiusscale", $(filterscale), \
								$(channel), $(channeldata)
	#elif RENDERER == _3delight
	#define SHADEOP_ARGUMENTS	"coordsystem", $(coordsys), \
								"filterradius", $(filterradius), \
								"filterscale", $(filterscale), \
								"maxdepth", $(maxdepth), \
								$(channel), $(channeldata)
	#elif RENDERER == prman
	#define SHADEOP_ARGUMENTS	"coordsystem", $(coordsys), \
								"filterradius", $(filterradius), \
								"filterscale", $(filterscale), \
								"maxdepth", $(maxdepth), \
								"lerp", $(interpolate), \
								$(channel), $(channeldata)
	#elif RENDERER == air
	#define SHADEOP_ARGUMENTS	"width", $(filterscale), \
								"blur", $(filterradius), \
								$(channel), $(channeldata)
	#else /* Aqsis has no texture3d(), what about bmrt, entropy, renderdotc? */
		#ifndef NOSHADEOP
		#define NOSHADEOP
		#endif /* NOSHADEOP */
	#endif /* RENDERER */

	#ifdef NOSHADEOP
		$(channeldata) = 0;
		$(status) = 0; /* failure */
	#else
		$(status) = texture3d( $(bakefile), $(P), $(N),
							SHADEOP_ARGUMENTS );
	#endif /* NOSHADEOP */

	#undef NOSHADEOP
	#undef SHADEOP_ARGUMENTS
			
	</rsl_code>
	<usage>Performs a lookup of the supplied data pair, on files created by &quot;bake3d&quot;. Returns 1 if sucessful, 0 otherwise.</usage>
</shrimp>

</block>
